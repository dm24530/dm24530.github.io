<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="MingKing">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>MingKing</title>
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/dm24530/dm24530.github.io@master/favicon.ico?v=1614083969609">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/dm24530/dm24530.github.io@master/media/css/gemini.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/dm24530/dm24530.github.io@master/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="https://cdn.jsdelivr.net/gh/dm24530/dm24530.github.io@master/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/dm24530/dm24530.github.io@master/styles/main.css">

<script src="https://cdn.jsdelivr.net/gh/dm24530/dm24530.github.io@master/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>MingKing</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item nav-item-active">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="https://cdn.jsdelivr.net/gh/dm24530/dm24530.github.io@master/images/avatar.png"/>
    <p class="site-author-name">MingKing</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">46</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/dm24530">
              <i class="fa fa-github" title="github"></i>
            </a>
          
        
        
      </div>
    </div>
  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box gemini">
          <section class="section  posts-expand slide-down-in">
            
  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dm24530.GitHub.io/post/zuo-ye-3/">
      作业3
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-06-30 17:11:35">2020-06-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dm24530.GitHub.io/tag/lnoJshuwJl/">
        <span>数据科学导论</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>7<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1737<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
      <div class="post-body">
        
        
          
            <!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 -->
            
            
              
              
              
            
              
              
              
            
              
              
              
            
            
              <p><p>♦  从Python3.5开始，Python引入了新的矩阵乘法运算符“@”，*运算符不再用于矩阵相乘，专门用于按位操作，参与计算的两个矩阵（向量）维数相同，两个矩阵相同位置的对应元素进行操作；矩阵加法必须要求两个矩阵行列数一致。</p>
<p>♦<span style="display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: 'Noto Serif',serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;">  <a href="http://www.cainiaoxueyuan.com/bc/5893.html">numpy.matlib</a>矩阵生成函数</span><br>
numpy.matlib.empty()函数返回一个新的矩阵，而不初始化元素<br>

                
              <p>
            
          
        
        
        <div class="post-button text-center">
          <a class="btn language" data-lan="read-more" href="https://dm24530.GitHub.io/post/zuo-ye-3/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dm24530.GitHub.io/post/34-yi-chang-jian-ce-yu-chu-li/">
      3.4 异常检测与处理
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-06-30 17:10:52">2020-06-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dm24530.GitHub.io/tag/lnoJshuwJl/">
        <span>数据科学导论</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>5<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1279<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
      <div class="post-body">
        
        
          
            <!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 -->
            
            
              
              
              
            
              
              
              
            
              
              
              
            
            
              <p><p>数据点成为异常值主要有三种原因：<br>
♦ <b>数据</b><b>点表示极少发生的事件</b>，但它仍然是一个可能的数据，因为数据分布提供的数据只是一个样本。这时，所有点的产生过程都是相同的，但是异常点由于它的稀缺性而不符合某种推断。在这种情况下，常用的方法是将<b>去除</b><b>这样</b><b>的</b><b>点或</b><b>降低权重</b>，另一种解决方法是<b>增加样本数量</b>。<br>
<span style="display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: 'Noto Serif',serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;">♦ </span> <b>数据点表示经常发生的另一种分布。</b>当类似情况出现时，可认为是发生了影响样本生成的错误。<b>这样</b><b>的异常值必须去除</b>。<br>

                
              <p>
            
          
        
        
        <div class="post-button text-center">
          <a class="btn language" data-lan="read-more" href="https://dm24530.GitHub.io/post/34-yi-chang-jian-ce-yu-chu-li/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dm24530.GitHub.io/post/zuo-ye-4/">
      作业4
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-06-30 17:09:40">2020-06-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dm24530.GitHub.io/tag/lnoJshuwJl/">
        <span>数据科学导论</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>320<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
      <div class="post-body">
        
        
          
            <!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 -->
            
            
              
              
              
            
              
              
              
            
              
              
              
            
            
              <p><p>♦ <strong>nunique()</strong><br>
nunique()可直接统计dataframe中每列的不同值的个数。<br>
nunique()可直接统计series中不同值的个数，但不能用于list。<br>

                
              <p>
            
          
        
        
        <div class="post-button text-center">
          <a class="btn language" data-lan="read-more" href="https://dm24530.GitHub.io/post/zuo-ye-4/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dm24530.GitHub.io/post/zuo-ye-2/">
      作业2
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-06-30 17:08:48">2020-06-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dm24530.GitHub.io/tag/lnoJshuwJl/">
        <span>数据科学导论</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>351<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
      <div class="post-body">
        
        
          
            <!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 -->
            
            
              
              
              
            
              
              
              
            
              
              
              
            
            
              <p><p>对于数据集dataset以文本形式输出为<img src="https://p.ananas.chaoxing.com/star3/origin/7210d84e067be607ee479483bc18e573.png"  width="30px"/>，若要输出数值40的，代码正确的是（）。</p>
<p>这个就是个数据选择的问题,可以使用的方法有：<br>
dataset['val2',103]，dataset.loc[103,'val2']，dataset.ix[103 ,'val2']，dataset.ix[103,1]，dataset.iloc[3,1]</p>

                
              <p>
            
          
        
        
        <div class="post-button text-center">
          <a class="btn language" data-lan="read-more" href="https://dm24530.GitHub.io/post/zuo-ye-2/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dm24530.GitHub.io/post/zuo-ye-5/">
      作业5
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-06-30 17:04:59">2020-06-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dm24530.GitHub.io/tag/lnoJshuwJl/">
        <span>数据科学导论</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>3<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>673<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
      <div class="post-body">
        
        
          
            <!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 -->
            
            
              
              
              
            
              
              
              
            
              
              
              
            
            
              <p><p>import pandas<br>
help(pandas.DataFrame.describe)查询生成描述性统计数据的函数帮助<br>
DataFrame.describe(percentiles=None, include=None, exclude=None)<br>

                
              <p>
            
          
        
        
        <div class="post-button text-center">
          <a class="btn language" data-lan="read-more" href="https://dm24530.GitHub.io/post/zuo-ye-5/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dm24530.GitHub.io/post/zheng-ze-biao-da-shi/">
      正则表达式
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-06-30 17:03:58">2020-06-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dm24530.GitHub.io/tag/lnoJshuwJl/">
        <span>数据科学导论</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>6<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1383<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
      <div class="post-body">
        
        
          
            <!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 -->
            
            
              
              
              
            
              
              
              
            
              
              
              
            
            
              <p><div id="article_content" class="article_content clearfix">
<div id="content_views" class="htmledit_views">
<h3>正则表达式</h3>

                
              <p>
            
          
        
        
        <div class="post-button text-center">
          <a class="btn language" data-lan="read-more" href="https://dm24530.GitHub.io/post/zheng-ze-biao-da-shi/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dm24530.GitHub.io/post/ju-lei-wen-ti/">
      聚类问题
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-06-30 17:01:27">2020-06-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dm24530.GitHub.io/tag/lnoJshuwJl/">
        <span>数据科学导论</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>3<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>761<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
      <div class="post-body">
        
        
          
            <!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 -->
            
            
              
              
              
            
              
              
              
            
              
              
              
            
            
              <p><div id="article_content" class="article_content clearfix">
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
<p>聚类问题是无监督学习，算法的思想是“物以类聚，人以群分”。聚类算法感知样本间的相似度，进行类别归纳，对新的输入进行输出预测，输出变量取有限个离散值</p>

                
              <p>
            
          
        
        
        <div class="post-button text-center">
          <a class="btn language" data-lan="read-more" href="https://dm24530.GitHub.io/post/ju-lei-wen-ti/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dm24530.GitHub.io/post/matplotlib-ku-python-shu-ju-ke-shi-hua/">
      Matplotlib库-Python数据可视化
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-06-30 16:59:48">2020-06-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dm24530.GitHub.io/tag/lnoJshuwJl/">
        <span>数据科学导论</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>19<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>4090<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
      <div class="post-body">
        
        
          
            <!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 -->
            
            
              
              
              
            
              
              
              
            
              
              
              
            
            
              <p><div id="article_content" class="article_content clearfix">
<div id="content_views" class="htmledit_views">
<h1><a name="t0"></a><a name="t0"></a>Matplotlib基础</h1>

                
              <p>
            
          
        
        
        <div class="post-button text-center">
          <a class="btn language" data-lan="read-more" href="https://dm24530.GitHub.io/post/matplotlib-ku-python-shu-ju-ke-shi-hua/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dm24530.GitHub.io/post/tan-suo-xing-shu-ju-fen-xi-edaexploratory-data-analysis/">
      探索性数据分析EDA(Exploratory Data Analysis)
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-06-30 16:39:58">2020-06-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dm24530.GitHub.io/tag/CfTRE6KVgT/">
        <span>数据库</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>35<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>9576<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
      <div class="post-body">
        
        
          
            <!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 -->
            
            
              
              
              
            
              
              
              
            
              
              
              
            
            
              <p><div id="content_views" class="htmledit_views">
<p style="margin-left: 0in;"><span style="color: #000000;">EDA</span><span style="color: #000000;">的主要工作是：对数据进行清洗，对数据进行描述（描述统计量，图表），查看数据的分布，比较数据之间的关系，培养对数据的直觉，对数据进行总结等。 </span></p>
<div style="margin-left: .81in;">-<span style="color: #000000;">“探索性”指</span><span style="color: #000000;">分析者对待解问题的理解会随着研究的深入不断</span><span style="color: #000000;">变化</span></div>

                
              <p>
            
          
        
        
        <div class="post-button text-center">
          <a class="btn language" data-lan="read-more" href="https://dm24530.GitHub.io/post/tan-suo-xing-shu-ju-fen-xi-edaexploratory-data-analysis/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dm24530.GitHub.io/post/zuo-ye-11/">
      作业1.1
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-06-30 16:17:50">2020-06-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dm24530.GitHub.io/tag/CfTRE6KVgT/">
        <span>数据库</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>4<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>976<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
      <div class="post-body">
        
        
          
            <!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 -->
            
            
              
              
              
            
              
              
              
            
              
              
              
            
            
              <p><p>在数据管理技术发展过程中，完全需要应用程序自己动手管理数据的是<strong>人工管理阶段</strong><br>
长期存储在计算机内，有组织的、可共享的大量数据的集合是<strong>数据库（DataBase）</strong><br>
数据管理技术经历了若干阶段，其中人工管理阶段和文件系统阶段相比文件系统的一个显著的优势是<strong>数据可以长期保存</strong></p>

                
              <p>
            
          
        
        
        <div class="post-button text-center">
          <a class="btn language" data-lan="read-more" href="https://dm24530.GitHub.io/post/zuo-ye-11/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>
  
            
            
<div class="page bg-color">
  <ul class="pagination-ul">
    
      <li class="pagination-dir">
        <a href="https://dm24530.GitHub.io/page/3/">
          <i class="fa fa-angle-left"></i>
        </a>
      </li>
    
    
      
        <li class="pagination-li ">
            <a href="/page/../">
              1
            </a>
        </li>
      
        <li class="pagination-li ">
            <a href="/page/2">
              2
            </a>
        </li>
      
        <li class="pagination-li ">
            <a href="/page/3">
              3
            </a>
        </li>
      
        <li class="pagination-li pagination-active">
            <a href="/page/4">
              4
            </a>
        </li>
      
        <li class="pagination-li ">
            <a href="/page/5">
              5
            </a>
        </li>
      
    
    
      <li class="pagination-dir">
        <a href="/page/5">
          <i class="fa fa-angle-right"></i>
        </a>
      </li>
    
  </ul>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
  <div class="aplayer" id="aplayer"></div>
  <script>
  let musics = JSON.parse('[{"author":"Taylor Swift","cover":"http://d.musicapp.migu.cn/prod/file-service/file-down/8121e8df41a5c12f48b69aea89b71dab/29b643f5a7fd468badab4b6c0d0b55dd/ecb74ffe1a6f6866caf855da51e48876","lrc":"https://app.onenine.cc/m/api/lrc/migu/id/db39hshZKEE9AXOn-9sEPbGVXFb37fa4nFdCKxYoLKxkDpBeKYjcizKSp1pS0CeL57NNRP7JIRS7QeYKtR5_9USJ97rHZFB9hWxGHa0XpM3agpXVHsbGfDknNWhGOmKBhBDds-9mRVz04BLd4UQqAVJm4tCeXXeBNnaCl-VxmSLwB3c0STOLLrxK3ToX8WCfEXSCkuzOLIBAPdMbQUrtfntSBv4ybCTyFmnvv9G7dyNdgFcpfw/name/willow%20-%20Taylor%20Swift.lrc","musicLink":"http://218.205.239.34/MIGUM2.0/v1.0/content/sub/listenSong.do?toneFlag=HQ&netType=00&copyrightId=0&contentId=600908000007286336&resourceType=2&channel=0","musicName":"willow"},{"author":"Taylor Swift","cover":"http://d.musicapp.migu.cn/prod/file-service/file-down/8121e8df41a5c12f48b69aea89b71dab/29b643f5a7fd468badab4b6c0d0b55dd/ecb74ffe1a6f6866caf855da51e48876","lrc":"https://app.onenine.cc/m/api/lrc/migu/id/db39hshZKEE9AXOn-9sEPbGVXFb37fa4nFdCKxYoLKxkDpBeKYjcizKSp1pS0CeL57NNRP7JIRS7QeYKtR5_9USJ97rHZFB9hWxGHa0XpM3agpXVHsbGfDknNWhGOmKBhBDds-9mRVz04BLd4UQqAVJm4tCeXXeBNnaCl-VxmSLwB3c0STOLLrxK3ToX8WCfEXSCkuzOLIBAPdMbQUrtfntSBv4ybCTyFmnvv9G7dyNdgFcpfw/name/willow%20-%20Taylor%20Swift.lrc","musicLink":"http://218.205.239.34/MIGUM2.0/v1.0/content/sub/listenSong.do?toneFlag=HQ&netType=00&copyrightId=0&contentId=600908000007286336&resourceType=2&channel=0","musicName":"willow"}]');
  let mediaMusic = [];
  for (let i = 0; i < musics.length; i++) {
    let item = musics[i];
    mediaMusic.push({
      name: item.musicName,
      artist: item.author,
      url: item.musicLink,
      lrc: item.lrc,
      cover: item.cover
    });
  }

  const ap = new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      lrcType: 3,
      listFolded: false,
      listMaxHeight: 90,
      audio: mediaMusic
  });
  window.addEventListener('load', function() {
    let postBody = document.querySelector('#post_body');
    let hs = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
    postBody && hs.forEach(h => {
      let helems = postBody.querySelectorAll(h);
      if (helems.length > 0) {
        helems.forEach(elem => {
          elem.id = encodeURI(elem.id);
        })
      }
    })
  })
  </script>


  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  console.log(images);
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>
  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/cao-zuo-xi-tong-si-wei-dao-tu-ling-ji-chu-si-wei-dao-tu-xiang-xi-ban-ben-ji-zhi-shi-dian/"" data-c="
          &lt;article class=&#34;baidu_pl&#34;&gt;
        &lt;div id=&#34;article_content&#34; class=&#34;article_content clearfix&#34;&gt;
        &lt;link rel=&#34;stylesheet&#34; href=&#34;https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css&#34;&gt;
                &lt;div id=&#34;content_views&#34; class=&#34;markdown_views prism-atelier-sulphurpool-light&#34;&gt;
                    &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; style=&#34;display: none;&#34;&gt;
                        &lt;path stroke-linecap=&#34;round&#34; d=&#34;M5,0 0,2.5 5,5z&#34; id=&#34;raphael-marker-block&#34; style=&#34;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#34;&gt;&lt;/path&gt;
                    &lt;/svg&gt;
&lt;h2&gt;第一章 操作系统引论及概述&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200704184928841.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt; 
&lt;p&gt;1.操作系统(Operating System，OS)是计算机系统中最重要的系统软件，它管理整个计算机系统的软件资源和硬件资源，是用户与计算机硬件的桥梁，是其它软件和程序的运行基础。&lt;/p&gt; 
&lt;p&gt;2.操作系统可以控制CPU的工作、访问存储器、进行设备驱动和设备中断处理。&lt;/p&gt; 
&lt;p&gt;3.计算机用户可以通过操作系统使用不同的界面，方便、快捷、安全、可靠地操作计算机硬件来完成自己的计算任务。&lt;/p&gt; 
&lt;p&gt;4.操作系统是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。&lt;/p&gt; 
&lt;p&gt;5.操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。&lt;/p&gt; 
&lt;p&gt;6.操作系统是计算机硬件之上的第一层软件，屏蔽了硬件的物理特性和操作细节，用户通过操作系统来使用计算机系统。&lt;/p&gt; 
&lt;p&gt;7.用户在操作系统的帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。&lt;/p&gt; 
&lt;p&gt;8.作为系统资源的管理者，操作系统主要做以下工作：&lt;br&gt; （1）监视各种资源，随时记录它们的状态。&lt;br&gt; （2）实施某种策略以决定谁获得资源，何时获得，获得多少。&lt;br&gt; （3）分配资源供需求者使用。&lt;br&gt; （4）回收资源，以便再次分配。&lt;/p&gt; 
&lt;p&gt;9.多道程序设计&lt;br&gt; 指允许多个程序同时进入内存并运行。即同时把多个程序装入内存，并允许它们交替在CPU中运行，它们共享系统中的各种硬件资源和软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。&lt;br&gt; 多道程序合理搭配以输入/输出为主和以计算为主的程序，使得它们交替运行，从而充分利用资源，提高系统效率。&lt;/p&gt; 
&lt;p&gt;10.多道批处理作业&lt;br&gt; ①多道&lt;br&gt; 系统内可同时容纳多个作业。这些作业存放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，作业的调度由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。&lt;br&gt; ②成批&lt;br&gt; 在系统运行过程中，不允许用户与其作业发生交互作用，即作业一旦进入系统，用户就不能直接干预其作业的运行&lt;/p&gt; 
&lt;p&gt;11.多道批处理系统的主要特征有以下三个方面：&lt;br&gt; ①用户脱机使用计算机：作业提交后直到获得结果之前，用户无法与作业交互。&lt;br&gt; ②作业成批处理：采用成批处理作业。&lt;br&gt; ③多道程序并行：充分利用系统资源。&lt;br&gt; 多道批处理系统的缺点:&lt;br&gt; 是无交互性，用户一旦提交作业就失去了对其运行的控制能力；同时，由于是批处理，所以作业的周转时间长，用户使用不方便。&lt;/p&gt; 
&lt;p&gt;12.分时技术把处理器的时间分成很短的时间片，这些时间片轮流地分配给各个联机的作业使用。&lt;/p&gt; 
&lt;p&gt;如果某作业在分配给它的时间片用完时仍未完成，则该作业暂时中断，等待下一轮运行，并把处理器的控制权让给另一个作业使用。&lt;/p&gt; 
&lt;p&gt;这样在一个相对较短的时间间隔内，每个用户作业都能得到快速响应，以实现人机交互。&lt;/p&gt; 
&lt;p&gt;13.实时系统主要包括三种：&lt;br&gt; （1）过程控制系统&lt;br&gt; （2）信息查询系统&lt;br&gt; （3）事务处理系统&lt;/p&gt; 
&lt;p&gt;14.实时操作系统（Real Time Operating System）&lt;br&gt; 是指当外界事件或数据产生时，能够接收并以足够快的速度予以处理，其处理的结果又能在规定的时间之内控制监控的生产过程或对处理系统做出快速响应，并控制所有实时任务协调一致运行的操作系统。&lt;/p&gt; 
&lt;p&gt;15.服务器操作系统 (Server operating system，SOS )，又称为网络操作系统，一般指的是安装在大型计算机上的操作系统，比如Web服务器、应用服务器和数据库服务器等，是企业IT系统的基础架构平台。&lt;/p&gt; 
&lt;p&gt;服务器操作系统也可以安装在个人电脑上。相比个人版操作系统，在一个具体的网络中，服务器操作系统要承担额外的管理、配置、稳定、安全等功能，处于每个网络中的心脏部位。&lt;/p&gt; 
&lt;p&gt;16.操作系统的功能&lt;br&gt; 1）处理机管理&lt;br&gt; （2）存储管理&lt;br&gt; （3）设备管理&lt;br&gt; （4）文件系统管理&lt;br&gt; （5）用户接口管理&lt;/p&gt; 
&lt;p&gt;17.（1）处理机管理&lt;br&gt; 计算机系统中最重要的资源是中央处理机（简称CPU），任何计算都必须在CPU上进行。&lt;br&gt; 在处理机管理中，最核心的问题是CPU时间的分配问题，这涉及分配的策略和方法。&lt;br&gt; 在单CPU计算机系统中，当有多进程请求CPU时，将处理机分配给那个进程使用的问题就是处理机分配的策略问题。调度策略也是分配原则，这是在多对一的情况下（即多个进程竞争1个CPU）必须确定的。&lt;br&gt; 这些原则因系统的设计目标不同而不同。可以按进程的紧迫程度，或按进程发出请求的先后次序，或是其他的原则来确定处理机的分配原则。&lt;br&gt; （2）存储管理&lt;br&gt; 存储管理的主要工作是对内存储器进行合理分配、有效保护和扩充。&lt;br&gt; 内存是现代计算机系统的中心，是可以被CPU和I/O设备共同访问的数据仓库。&lt;br&gt; 内存通常是CPU直接寻址和访问的、唯一的大容量存储器。&lt;br&gt; （3）设备管理&lt;br&gt; 设备管理是操作系统中最庞杂、琐碎的部分，其原因是：&lt;br&gt; ①设备管理涉及很多实际的物理设备，这些设备品种繁多、用法各异。&lt;br&gt; ②各种外部设备都能和主机并行工作，而且，有些设备可被多个进程所共享。&lt;br&gt; ③主机和外部设备，以及各类外部设备之间的速度极不匹配，极差很大。&lt;br&gt; （4）文件系统管理&lt;br&gt; 以上三种管理都是针对计算机的硬件资源的管理。&lt;br&gt; 文件系统管理则是对软件资源的管理。为了管理庞大的系统软件资源及用户提供的程序和数据，操作系统将它们组织成文件的形式，操作系统对软件的管理实际上是对文件系统的管理。&lt;br&gt; 文件系统要解决的问题是，为用户提供一种简便的、统一的存取和管理信息的方法，并要解决信息的共享、数据的存取控制和保密等问题。&lt;br&gt; 文件系统要实现用户的信息组织、提供存取方法、实现文件共享和文件安全，还要保证文件完整性，完成磁盘空间分配的任务。&lt;br&gt; （5）用户接口管理&lt;br&gt; 计算机用户与计算机的交流是通过操作系统的用户接口（或称用户界面）完成的。&lt;br&gt; 操作系统为用户提供的接口有两种，&lt;br&gt; 一是操作界面；&lt;br&gt; 二是操作系统的功能服务界面。&lt;/p&gt; 
&lt;p&gt;18.操作系统特征&lt;br&gt; （1）并行与并发&lt;br&gt; 　　并行性和并发性是既相似又有区别的两个概念：&lt;br&gt; 并行性是指两个或多个事件在同一时刻发生；&lt;br&gt; 并发性是指两个或多个事件在同一时间间隔内发生。&lt;br&gt; 在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。&lt;br&gt; 在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可同时执行。 　&lt;br&gt; （2）共享性&lt;br&gt; 共享是指系统中的资源可供内存中多个并发执行的进程(线程)&lt;br&gt; 共同使用，称为资源共享或资源复用。&lt;br&gt; （3）虚拟（virtual）性&lt;br&gt; 是指通过技术把一个物理实体变成若干个逻辑上的对应物。&lt;br&gt; 在操作系统中虚拟的实现主要是通过分时的使用方法。&lt;br&gt; （4）异步性&lt;br&gt; 进程以人们不可预知的速度向前推进，即进程的异步性。&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;第二章 进程与线程&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200704185044137.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt; 
&lt;p&gt;1.进程的定义： 进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和运行调度的基本单位。&lt;/p&gt; 
&lt;p&gt;2.进程控制块的概念及其内容&lt;br&gt; 一个进程创建后，需要有自己对应的程序和该程序运行时所需的数据，还需要数据结构来刻画进程的动态特征，描述进程状态，占有资源情况，调度信息等，通常使用一种称为进程控制块的数据结构来刻画。&lt;br&gt; 一个进程要由3个部分组成：程序、数据集合以及进程控制块。由于进程的状态在不断发生变化，某时刻进程的内容及其状态集合称之为进程映像（Process Image）,其包括进程控制块，进程程序段，进程核心栈和进程数据段4个要素。&lt;/p&gt; 
&lt;p&gt;3.（1）进程控制块是随着进程的创建而建立，随着进程的撤销而取消的。&lt;br&gt; （2）PCB是进程存在的唯一标志，是操作系统用来记录和刻画进程状态及有关信息的数据结构。&lt;br&gt; （3）进程控制块应常驻内存，其包括进程执行时的情况以及进程让出CPU之后所处的状态、断点等信息。&lt;/p&gt; 
&lt;p&gt;4.进程创建的原因&lt;br&gt; （1）用户登录。在一个交互式环境中，当一个新用户在终端键入登录命令后，若是合法用户，系统为该用户建立一个进程。&lt;br&gt; （2）提供服务。当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务。&lt;br&gt; （3）作业调度。在批处理系统中，当作业调度程序按一定的算法调度到某作业时，操作系统认为有资源可运行，便将该作业装入内存，为它分配必要的资源，并立即为它创建进程。&lt;br&gt; （4）应用请求。基于应用进程的需求，由它自己创建一个新进程，以便使新进程以并发运行的方式完成特定的任务。&lt;/p&gt; 
&lt;p&gt;5.三状态转换图&lt;br&gt; &lt;img src=&#34;https://img-blog.csdnimg.cn/2020070419162324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt; 6．三状态模型&lt;br&gt; （1）执行态（running）：进程占用处理器并执行的状态。在单处理器系统中，由于处理器的惟一性，至多只能有一个进程处于执行状态。&lt;br&gt; （2）就绪态（ready）：进程具备执行条件，即已分配到除处理器以外的所有必要的资源，等待系统分配处理器以便其运行的状态。&lt;br&gt; （3）阻塞态（blocked）：正在执行的进程由于发生某事件（如I/O请求，申请缓冲区失败）暂时无法继续执行时的状态，进程的执行受阻，此时引起进程调度，OS把处理机分配给另一个就绪进程，而让阻塞的进程处于暂停状态&lt;/p&gt; 
&lt;p&gt;7.引起进程状态转换的具体原因有以下几点。&lt;br&gt; （1）就绪态—执行态。进程调度程序根据调度算法把处理器分配给某个就绪进程，并把控制转到该进程，使它由就绪态变为执行态，进程投入运行。&lt;br&gt; （2）执行态—就绪态。执行中的进程因所分配给它的时间片用完而被暂停运行时，该进程便由执行态回到就绪态。&lt;br&gt; （3）执行态—阻塞态。因发生某事件而使进程的执行受阻（例如等待文件的输入），使得进程无法继续执行，该进程将由执行态变为阻塞态。&lt;br&gt; （4）阻塞态—就绪态。阻塞进程在所等待的事件完成后，并不能立即投入运行，需要通过进程调度程序统一调度才能获得处理器，此时将该进程的状态变为就绪态继续等待处理机。&lt;/p&gt; 
&lt;p&gt;8.五状态转换&lt;br&gt; &lt;img src=&#34;https://img-blog.csdnimg.cn/20200704191816991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt; 
&lt;p&gt;9.（1）新建态（new）。进程刚建立，还没有被OS提交到可运行进程队列。&lt;br&gt; （2）终止态（exit）。进程已正常或异常结束，被OS从可运行进程队列中释放出来。&lt;br&gt; 处于终止态的进程不再被调度执行，在与该任务相关的表格或其它信息抽取完毕以后，OS也不必再保存与进程有关的信息。&lt;/p&gt; 
&lt;p&gt;10.（ 1）新建态—就绪态。对一个处于新建态的进程，在就绪队列能够接纳新进程时，将被系统接收并进入就绪队列，此时的进程状态就从新建态转为就绪态。&lt;br&gt; （2）执行态—终止态。对于一个处于执行状态的进程，当其正常执行结束，或者因为发生了某种事件而被异常结束&lt;/p&gt; 
&lt;p&gt;11.七状态模型&lt;/p&gt; 
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200704191953550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt; 
&lt;p&gt;12.（1）挂起就绪态（ready suspend）。进程具备运行条件，但目前在辅助存储器中，只有当进程被兑换到主存时才能调度执行。&lt;br&gt; （2）挂起阻塞态（blocked suspend）。进程正在等待某一事件发生且进程在辅助存储器中。&lt;/p&gt; 
&lt;p&gt;13.线程（Thread）是现代操作系统中出现的一个重要技术，目前流行的操作系统几乎都采用了线程机制。线程的引入进一步提供了程序执行的并发性，提高了系统的效率。&lt;br&gt; 在传统的操作系统中，进程是系统进行资源分配和调度的基本单位，以进程为单位分配存放其映像所需要的虚地址空间，执行所需要的主存空间，完成任务需要的其他各类外围设备资源和文件。&lt;/p&gt; 
&lt;p&gt;14.所谓线程，是进程内的一个相对独立的，可独立调度和指派的执行单元。是进程的组成部分。线程的组成部分有：&lt;br&gt; （1）线程的唯一标识符及线程状态信息，即线程控制块（TCB）。&lt;br&gt; （2）未运行时所保存的进程上下文，可把线程看成进程中一个独立的程序计数器。&lt;br&gt; （3）核心栈，在核心态工作时保存参数，在函数调用时返回地址，等等。&lt;br&gt; （4）用于存放线程局部变量和用户栈的私有存储区。&lt;/p&gt; 
&lt;p&gt;15.线程是个动态的概念，也有生命周期，在这一过程中它具有各种状态，虽然在不同的操作系统中，线程的状态不完全相同，但下述三个关键的状态是共有的。&lt;br&gt; （1）就绪状态：线程已具备执行条件，调度程序可以为其分配一个CPU执行。&lt;br&gt; （2）运行状态：线程正在某一个CPU内运行。&lt;br&gt; （3）阻塞状态：线程正在等待某个事件发生，则被阻塞。&lt;/p&gt; 
&lt;p&gt;16.线程具有以下一些特征。&lt;br&gt; （1）线程是进程中的一个相对可独立运行的单元。&lt;br&gt; （2）线程是操作系统中的基本调度单位，在线程中包含调度所需要的基本信息。&lt;br&gt; （3）在具备线程机制的操作系统中，进程不再是调度单位，一个进程中至少包含一个线程，以线程作为调度单位。&lt;br&gt; （4）线程自己并不拥有资源，它与同进程中的其它线程共享该进程所拥有的资源。由于线程之间涉及资源共享，所以需要同步机制来实现进程内多线程之间的通信。&lt;br&gt; （5）与进程类似，线程还可以创建其他线程，线程也有生命周期，也有状态的变化。&lt;/p&gt; 
&lt;p&gt;17.周转时间：从作业提交给系统到作业完成为止的这段时间间隔。&lt;br&gt; 周转时间包括四部分：作业在外存后备队列上等待(作业)调度的时间+进程在就绪队列上等待进程调度的时间+进程在CPU上执行的时间+以及进程等待I/O操作完成的时间。&lt;br&gt; 一个作业的周转时间等于作业的完成时间-到达时间，或者是执行时间+等待时间。&lt;/p&gt; 
&lt;p&gt;18.抢占式优先级调度方式规定首先把处理机分配给优先权最高的进程，使该进程占用CPU执行。但在其执行期间，如果系统中进入了一个优先权更高的进程，进程调度程序就立即停止当前进程（原优先权最高的进程）的执行，重新将处理器分配给新到的优先级最高的进程。这种调度方式的优点是能更好地满足紧迫作业的要求，因此适用于要求比较严格的实时系统，以及对性能要求较高的批处理和分时系统。&lt;br&gt; 　　在优先级调度算法中，进程的优先级一般由优先数决定。&lt;/p&gt; 
&lt;p&gt;19.静态优先数是指进程在创建时就获得一个整数数值，此数值在进程的整个运行过程中固定不变。优先数的大小反映进程优先级的高低。有的系统规定越大的优先数其优先级越高，当然也可以反过来规定。优先数的决定一般取决于进程类型，资源需求量，紧迫程度和用户需求等。&lt;/p&gt; 
&lt;p&gt;20.动态优先数是指进程的优先级随着进程的推进可以动态改变。现代操作系统中，采用优先级调度算法的系统大多使用的是动态优先数的策略。动态优先数的选择可以根据进程占有CPU的时间长短以及就绪进程等待CPU的时间长短来确定。&lt;/p&gt; 
&lt;p&gt;21.用户级线程调度和核心级线程调度的主要区别如下。&lt;br&gt; （1）用户级线程间切换只需少量机器指令，速度较快；而核心级线程间切换需要完整的进程上下文切换，修改内存映像，高速缓存失效，因而速度慢。系统开销大。&lt;br&gt; （2）用户级线程可使用专为某用户态程序定制的线程调度程序，应用定制的线程调度程序能够比内核更好地满足用户态程序需要。核心级线程在内核中完成线程调度，内核不了解每个线程的作用，不能做到这一点。&lt;/p&gt; 
&lt;hr&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第三章 进程并发控制&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200704185128296.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt; 
&lt;p&gt;1.把并发进程中与共享变量有关的程序段称为“临界区”&lt;/p&gt; 
&lt;p&gt;2.共享变量所代表的资源称为“临界资源”&lt;/p&gt; 
&lt;p&gt;3.多个并发进程中涉及相同共享变量的那些程序段称为“相关临界区”&lt;/p&gt; 
&lt;p&gt;4.若干进程共享某一资源（变量）的相关临界区的管理应满足如下三个要求：&lt;br&gt; （1）一次最多让一个进程在临界区执行，当有进程在临界区执行时，其他想进入临界区执行的进程必须等待。&lt;/p&gt; 
&lt;p&gt;（2）任何一个进入临界区执行的进程必须在有限的时间内退出临界区，即任何一个进程都不应该无限地逗留在自己的临界区中。&lt;/p&gt; 
&lt;p&gt;（3）不能强迫一个进程无限地等待进入它的临界区，即有进程退出临界区时应让一个等待进入临界区的进程进入它的临界区。&lt;/p&gt; 
&lt;p&gt;5.进程的互斥是指当有若干进程都要使用某一共享资源时，任何时刻最多只允许一个进程去使用，其他要使用该资源的进程必须等待，直到占用资源者释放该资源。&lt;/p&gt; 
&lt;p&gt;6.信号量：在操作系统中，信号量S是一个整数。当S大于等于零时，代表可供并发进程使用的资源实体数；当S小于零时，则|S|表示正在等待使用资源实体的进程数。建立一个信号量必须说明此信号量所代表的意义并且赋初值。除赋初值外，信号量仅能通过PV操作来访问。&lt;/p&gt; 
&lt;p&gt;7.信号量按其用途可分为两种：&lt;br&gt; （1）公用信号量，联系一组并发进程，相关的进程均可在此信号量上进行P操作和V操作，初值常常为1，用于实现进程互斥，也称为互斥信号量。&lt;br&gt; （2）私有信号量，联系一组并发进程，仅允许拥有此信号量的进程执行P操作，而其他相关进程可在其上施行V操作。初值常常为0或正整数，多用于实现进程同步，也称为资源信号量。&lt;/p&gt; 
&lt;p&gt;8.我们把不可被中断的过程称为“原语”，于是P操作和V操作实际上是“P操作原语”和“V操作原语”。P、V操作也分别称为Wait()和Signal()操作。&lt;/p&gt; 
&lt;p&gt;9.用PV操作可实现并发进程的互斥，其步骤为：&lt;br&gt; (1）设立一个互斥信号量S表示临界区，其取值范围为1，0， -1，…，其中S ＝1表示无并发进程进入S临界区；S＝0表示已有一个并发进程进入S临界区；S等于负数表示已有一个并发进程进入S临界区，且有|S|个进程等待进入S临界区。S的初值为1。&lt;br&gt; (2）用PV操作表示对S临界区的申请和释放，在进入临界区之前，通过P操作进行申请，在退出临界区之后，通过V操作释放。&lt;/p&gt; 
&lt;p&gt;10.程是由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：&lt;br&gt; （ 1）局部数据变量只能被管程的过程访问，任何外部过程都不能访问。&lt;br&gt; （2）一个进程通过调用管程的一个过程进入管程。&lt;br&gt; （3）在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。&lt;/p&gt; 
&lt;p&gt;11.高级通信机制可归结为三大类：&lt;br&gt; 共享存储器系统&lt;br&gt; 消息传递系统&lt;br&gt; 管道通信系统&lt;/p&gt; 
&lt;p&gt;12.消息传递系统的通信方式属于高级通信方式。根据实现方式的不同可分为直接传递方式和间接传递方式。&lt;/p&gt; 
&lt;p&gt;13.管道，是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称为pipe文件。&lt;/p&gt; 
&lt;p&gt;向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入管道；而接受管道输出的接收进程（即读进程），可从管道中接收数据。由于发送进程的接收进程是利用管道进行通信的，故又称为管道通信。&lt;/p&gt; 
&lt;p&gt;14.管道通信机制必须提供以下三方面的协调能力：&lt;br&gt; （ 1）互斥。当一个进程正对pipe进行读/写操作时，另一个进程必须等待。&lt;br&gt; （2）同步。当写（输入）进程把一定数量数据写满pipe时，应睡眠等待，直到读（输出）进程取走数据后，再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将它唤醒。&lt;br&gt; （3）判断对方是否存在。只有确定对方已存在时，方能进行通信。&lt;/p&gt; 
&lt;p&gt;15.直接传递是指发送进程利用操作系统所提供的发送命令直接把消息发送给接收进程，而接收进程则利用接收命令直接从发送进程接收消息。&lt;br&gt; 在直接通信方式下，企图发送或接收消息的每个进程必须指出信件发给谁或从谁那里接收消息&lt;/p&gt; 
&lt;p&gt;16.send (P，消息)：把一个消息发送给进程P。&lt;br&gt; receive (Q，消息)：从进程Q 接收一个消息。&lt;br&gt; 进程P和Q通过执行这两个操作而自动建立了一种联系，并且这种联系仅仅发生在这一对进程之间。&lt;/p&gt; 
&lt;p&gt;17.在利用信箱通信时，在发送进程和接收进程之间存在着下述的四种关系：&lt;br&gt; 1）一对一关系。即可以为发送进程和接收进程建立一条专用的通信链路。使它们之间的交互不受其他进程的影响。&lt;br&gt; 2）多对一关系。允许提供服务的进程与多个用户进程之间进行交互，也称为客户/服务器交互。&lt;br&gt; 3）一对多关系。允许一个发送进程与多个接收进程进行交互，使发送进程可用广播形式，向接收者发送消息。&lt;br&gt; 4）多对多关系。允许建立一个公用信箱，让多个进程都能向信箱中投递消息，也可从信箱中取走属于自己的消息。&lt;/p&gt; 
&lt;hr&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第四章 死锁&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200704185823567.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt; 1.为了解决死锁问题，可使用下面几种对策。&lt;br&gt; 　　（1） 死锁的预防：破坏产生死锁的四个必要条件中的一个或多个，使系统不会进入死锁状态。&lt;br&gt; 　　（2）死锁的避免：在资源动态分配过程中使用某种算法防止系统进入不安全状态，从而避免死锁的发生。&lt;br&gt; 　　（3）死锁的检测：通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后，采取适当措施，从系统中将已发生的死锁清除掉。&lt;br&gt; 　　（4）死锁的解除：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞态的进程，使之转为就绪态，以继续运行。&lt;/p&gt; 
&lt;p&gt;2.死锁检测算法&lt;br&gt; （1）如果能在资源分配图中找出一个既不阻塞又非独立的进程，它在有限的时间内有可能获得所需资源类中的资源继续执行，直到运行结束，再释放其占有的全部资源。&lt;br&gt; （2）可使资源分配图中另一个进程获得前面进程释放的资源继续执行，直到完成父释放出它所占用的所有资源，相当于又消去了图中若干请求边和分配边。&lt;br&gt; （3）如此下去，经过一系列简化后，若能消去图中所有边，使所有进程成为孤立节点，则该图是可完全简化的。&lt;/p&gt; 
&lt;p&gt;3.从死锁中恢复&lt;br&gt; （1） 撤销进程&lt;br&gt; 　　解除死锁最直接的方法是终止一个或若干个进程，系统会回收分配给被终止进程的所有资源。在极端情况下，这种方法可能造成除一个死锁进程外，其余的死锁进程全部被撤销。&lt;br&gt; （2）剥夺资源　&lt;br&gt; 　　利用剥夺资源的方法处理死锁，需要考虑以下几点：&lt;br&gt; 1）选择剥夺哪些进程的哪些资源。与撤销进程相同，必须确定剥夺顺序确保代价最小化。&lt;br&gt; 2）对被剥夺资源的进程的安排。显然被剥夺资源的进程缺少所需要的资源，不能正常执行。建立检查点，必须将进程回到某个安全状态，以便从该状态重启进程。&lt;br&gt; 3）保证资源不会总是从同一个进程中被剥夺。这就需要确保一个进程只能有限次的剥夺资源，最常用的方法是在代价因素中加上回滚次数。&lt;/p&gt; 
&lt;p&gt;4.银行家算法&lt;br&gt; 把矩阵A11ocation和Need矩阵中的每一行当中一个向量，针对进程Pi已分配和还需要的向量分别写成A11ocationi和Needi。&lt;br&gt; 设Requesti为进程Pi的请求向量，如果Requesti[j]=k，那么进程Pi申请k个Rj类资源。银行家算法如下。&lt;br&gt; （1）申请量超过最大需求量时出错，否则转步骤（2）。&lt;br&gt; （2）当申请量超过当前系统所拥有的可分配量时，挂起进程，该进程处于阻塞态，否则转步骤（3）。&lt;br&gt; （3）系统对进程Pi请求的资源进行试探性分配，执行&lt;br&gt; Allocation[i，* ]= Allocation[i， * ]+Requesti[ * ]&lt;br&gt; Available[ * ]=Available[*]-Requesti[ * ]&lt;br&gt; Need[i， * ]=Need[i， * ]-Requesti[ * ]&lt;/p&gt; 
&lt;p&gt;5.死锁产生的根本原因有两个：一是系统中的资源数目不能满足多个并发进程的全部资源需求，各进程竞争资源，如系统对资源分配不合理就会产生死锁，简记为资源竞争：二是并发执行进程间的推进顺序不合理也可能产生死锁，简记为推进顺序非法。&lt;/p&gt; 
&lt;p&gt;6.系统产生死锁有四个必要条件：互斥条件、占有且等待条件、不抢占条件和环路等待条件。解决死锁的方法有：死锁检测和恢复、避免死锁、预防死锁。死锁的检测和恢复表示对资源的申请和分配不施加任何限制，但必须建立检测机制，周期性地检测是否发生死锁，如果检测发现死锁则采取措施恢复死锁。&lt;/p&gt; 
&lt;p&gt;7.活锁和饥饿是同死锁非常相似的问题，但在技术上不同，活锁包含的是实际并没有被锁住的进程，而饥饿可以通过先来先服务的分配策略来避免。&lt;/p&gt; 
&lt;p&gt;8.死锁的避免采用动态分析和检测新的资源请求和资源的分配情况，以确保系统始终处于安全状态，其中最著名的算法是银行家算法。死锁的预防包括一切都是用假脱机技术（破坏互斥条件），资源一次性分配(破坏占有且等待条件)；抢占资源(破坏不抢占条件)；资源有序分配法(破坏环路等待条件)。&lt;/p&gt; 
&lt;hr&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第五章 内存管理&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200704185228380.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt; 
&lt;p&gt;1.虚拟内存:中心思想是将物理主存扩大到便宜、大容量的磁盘上，即将磁盘空间看做主存空间的一部分。&lt;br&gt; 用户程序存放在磁盘上就相当于存放在主存内。用户程序既可以完全存放在主存，也可以完全存放在磁盘上，当然也可以部分存放在主存、部分存放在磁盘。而在程序执行时，程序发出的地址到底是在主存还是在磁盘则由操作系统的内存管理模块负责判断，并到相应的地方进行读写操作。&lt;/p&gt; 
&lt;p&gt;2.固定地址的内存管理其缺点也很明显：&lt;br&gt; （1）整个程序要加载到内存空间中去。这样将导致比物理内存大的程序无法运行。&lt;br&gt; （2）只运行一个程序造成资源浪费。如果一个程序很小，虽然所用内存空间小，但剩下的内存空间也无法使用。&lt;br&gt; （3）可能无法在不同的操作系统下运行，因为不同操作系统占用的内存空间大小可能不一样，使得用户程序的起始地址可能不一样。这样在一个系统环境下编译出来的程序很可能无法在另一个系统环境下执行。&lt;/p&gt; 
&lt;p&gt;3.固定分区的管理就是将内存分为固定的几个区域，每个区域的大小固定。最下面的分区为操作系统占用，其他分区由用户程序使用。这些分区大小可以一样，也可以不一样。考虑到程序大小不一的实际情况，分区的大小通常也各不相同。当需要加载程序时，选择一个当前闲置且容量够大的分区进行加载&lt;/p&gt; 
&lt;p&gt;4.地址翻译:物理地址＝虚拟地址+程序所在区域的起始地址&lt;/p&gt; 
&lt;p&gt;5.位图表示和链表表示的比较：&lt;br&gt; 位图表示和链表表示各有优缺点。&lt;/p&gt; 
&lt;p&gt;（1）如果程序数量很少，那么链表比较好，因为链表的表项数量少。位图表示法的空间成本是固定的，它不依赖于内存中程序的数量。因此，从空间成本上分析，到底使用哪种表示法得看链表表示后的空间成本是大于位图表示还是小于位图表示而定。&lt;/p&gt; 
&lt;p&gt;（2）从可靠性上看，位图表示法没有容错能力。如果一个分配单元为1，你并不能肯定它应该为1，还是因为错误变成1的，因为链表有被占空间和闲置空间的表项，可以相互验证，具有一定的容错能力。&lt;/p&gt; 
&lt;p&gt;（3）从时间成本上，位图表示法在修改分配单元状态时，操作很简单，直接修改其位图值即可，而链表表示法则需要对前后空间进行检查以便做出相应的合并。例如，在图4-18所示的情况下，如果程序中间的那个程序（占用位置从11开始，长度为4）终止，则链表将如图4-19所示。如果是最前面的程序终止，则链表将如图4-20所示。&lt;/p&gt; 
&lt;p&gt;6.分区分配算法&lt;br&gt; （1）首次适应算法FF。 空闲分区按地址递增顺序排列，&lt;br&gt; 找符合要求的第一分区。&lt;br&gt; （2） 循环首次适应算法，该算法是由首次适应算法演变而成的。&lt;br&gt; （3）最佳适应算法。空闲分区按大小递增顺序排列，&lt;br&gt; 找符合要求的第一分区。&lt;br&gt; （4）最坏适应算法。空闲分区按大小递减顺序排列，&lt;br&gt; 找符合要求的第一分区。&lt;br&gt; （5） 快速适应算法(quick fit)&lt;br&gt; 　　该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。&lt;/p&gt; 
&lt;p&gt;7.存储管理的基本功能有：主存空间的分配与回收、地址转换、主存空间的共享与保护、主存空间的扩充。&lt;/p&gt; 
&lt;p&gt;8.在多道程序设计系统中，为了方便程序编制，用户程序中使用的地址是逻辑地址，而CPU则是按物理地址访问主存、读取指令和数据。为了保证程序的正确执行，需要进行地址转换。地址转换又称为重定位，有静态重定位和动态重定位。采用动态重定位的系统支持程序的浮动。&lt;/p&gt; 
&lt;p&gt;9.现代操作系统支持多道程序设计，满足多道程序设计最简单的存储管理技术是分区管理，有固定分区管理和可变分区管理。分区管理中，当主存空间不足时，交换技术和覆盖技术可以达到扩充主存的目的。&lt;/p&gt; 
&lt;hr&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第六章 页式和段式内存管理&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200704185503505.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt; 
&lt;p&gt;1.在分页内存管理系统中，允许将进程的各页离散地装入内存的任何空闲物理块中，这样就出现了进程页号连续，而物理块号不连续的情况。为了找到每个页面在内存中对应的物理块，系统为每个进程建立了一张页面映射表，简称页表。&lt;/p&gt; 
&lt;p&gt;2.进程的所有页面依次在页表中有一个页表项，记载着相应页面在内存中对应的物理块号。当进程执行时，按照逻辑地址中的页号在页表中查找对应的页表项，找到该页号在内存中对应的物理块号。&lt;/p&gt; 
&lt;p&gt;3.页表的作用就是实现页号到物理块号的地址映射，即逻辑地址到物理地址的映射。&lt;/p&gt; 
&lt;p&gt;4.采用分页内存管理技术不会产生外部碎片，但是可能产生内部碎片。由于分页内存管理系统的内存分配是以物理块为单位进行的，如果进程要求的内存不是页大小的整数倍，那么，最后一个物理块就用不完，从而导致页内碎片的出现。&lt;/p&gt; 
&lt;p&gt;5.分页系统的另一个优点是可以共享共同的代码，这一点对分时系统特别重要。&lt;/p&gt; 
&lt;p&gt;6.快表：为了提高从逻辑地址向物理地址转换过程中地址的变换速度，可在地址变换机构中增设一个具有并行查询能力的特殊高速缓冲存储器，又称为“联想寄存器”（Associative Memory）或称为“快表”。在IBM系统中称为TLB（Translation Lookaside Buffer），存放当前访问的那些页表项。&lt;/p&gt; 
&lt;p&gt;7.具有快表的地址变换步骤如下：&lt;br&gt; （1）在CPU给出有效地址后，地址变换机构自动将页号P送入高速缓冲寄存器中，并将此页号与高速缓存中的所有页号进行比较。&lt;br&gt; （2）如果其中有与此页号匹配的，便表示所要访问的页表项在快表中。&lt;br&gt; （3）直接从快表中读出该页号所对应的物理块号，并送到物理地址寄存器中。&lt;br&gt; （4）如果在快表中未找到相同的页表号，则必须再访问内存中的页表，从页表中找到该页号所对应的页表项后，把从页表项中读出的物理块号送入地址寄存器。&lt;br&gt; （5）同时，将此页号所对应的页表项存入快表中，即重新修改快表。&lt;/p&gt; 
&lt;p&gt;8.内存抖动&lt;br&gt; 抖动产生的原因：&lt;br&gt; 当主存空间已经装满，而又需要转入新的页面时，必须按照一定的算法把已经在内存中的一些页面调出，这个工作称为页面替换。因此，页面更新算法就是用来确定应该淘汰哪些页面的算法，也称为淘汰算法。&lt;/p&gt; 
&lt;p&gt;9.防止抖动的方法&lt;br&gt; 防止抖动发生或者限制抖动影响有多种方法。由于抖动产生的原因，这些方法都是基于调节多道程序的度。&lt;br&gt; （1）采用局部置换策略。&lt;br&gt; （2）挂起某些进程。&lt;br&gt; 当出现CPU利用率很低而磁盘I/O非常频繁的情况时，可能因为多道程序度太高而造成抖动。为此，可以挂起一个或几个进程，腾出内存空间供抖动进程使用，从而消除抖动现象。被挂起进程的选择策略有多种，如选择优先权最低的进程、缺页进程、最近激活的进程、驻留集最小的进程、最大的进程。&lt;br&gt; （3）采用缺页频度法。&lt;br&gt; 抖动发生时，缺页率必然很高，因此可以通过控制缺页率来预防抖动。如果缺页率太高，表明进程需要更多的内存物理块；如果缺页率很低，表明进程可能占用了太多的内存物理块。这里规定一个缺页率，依次设置相应的上限和下限。如果实际缺页率超出上限值，就为该进程分配另外的内存物理块；如果实际缺页率低于下限值，就从该进程的驻留集中取走一个内存物理块。通过直接测量和控制缺页率，可以避免抖动。&lt;/p&gt; 
&lt;p&gt;10.段式内存管理的基本思想是：把程序按内容或过程（函数）关系分成段，每个段都有自己的名称。一个用户作业或进程所包含的段对应于一个二维线性虚拟空间，也就是一个二维虚拟存储器。段式管理程序以段为单位分配内存，然后通过地址映射机制把段式虚拟地址转换成实际的内存物理地址。&lt;/p&gt; 
&lt;p&gt;11.分段内存管理系统中以段为单位分配内存，每段分配一个连续的内存区。由于各段长度不等，所以这些存储区大小不等。此外，同一进程包含的各段之间不要求连续。分段内存管理的内存分配与释放在作业或进程的执行过程中动态进行。首先，分段内存管理程序为一个进入内存准备执行的进程或作业分配部分内存，以作为该进程的工作区和放置即将执行的程序段。随着进程的执行，进程根据需要随时申请调入新段和释放旧段。&lt;/p&gt; 
&lt;p&gt;12.分页与分段管理的主要区别&lt;br&gt; （1）页是信息的物理单位，段是信息的逻辑单位。&lt;br&gt; （2）页的大小是由系统确定的，而段的长度是由用户程序确定的。&lt;br&gt; （3）分页的进程地址空间是一维的，即单一的线性空间；而分段的进程地址空间是二维的，由段号和段内地址两部分组成。&lt;/p&gt; 
&lt;p&gt;14.在段页式内存管理系统中，要对内存中的指令或数据进行一次存取，至少需要三次以上访问内存：&lt;br&gt; 第一次访问内存：由段表地址寄存器得到段表的起始地址，从而访问段表，由此取出对应段的页表起始地址；&lt;br&gt; 第二次访问内存：根据页表的起始地址访问页表，得到所要访问的物理地址；&lt;br&gt; 第三次访问内存：根据得到的物理地址，访问内存中真正的物理单元。&lt;/p&gt; 
&lt;p&gt;15.虚拟内存&lt;br&gt; （1）常规存储器管理方式的特征&lt;br&gt; ①一次性：作业全部装入内存后才能开始运行。&lt;br&gt; ②驻留性：作业装入内存后，便一直驻留在内存中，直至作业运行结束。&lt;br&gt; （2）局部性原理&lt;br&gt; 程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。&lt;/p&gt; 
&lt;p&gt;19.局部性原理又表现为：时间局部性和空间局部性。&lt;br&gt; ①时间局部性&lt;br&gt; 现象：如果程序中某条指令一旦执行，则不久后该指令可能再次执行；如果某数据被访问过，则不久后该数据可能再次被访问。&lt;br&gt; 原因：程序中存在大量的循环操作。&lt;/p&gt; 
&lt;p&gt;20.虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。&lt;br&gt; 虚拟存储器的逻辑容量是内存容量和外存容量之和，最大容量由计算机的地址结构决定。虚拟存储器的运行速度接近内存，成本接近外存。&lt;/p&gt; 
&lt;hr&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第七章 I/O管理&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200704185555587.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt; 
&lt;p&gt;1.设备控制器是连接I/O设备和主机的中间接口，用来控制I/O和主机之间的数据交换。设备控制器可以接收主机发来的命令，从而控制外围设备，避免了主机直接处理繁杂的外围设备事务。&lt;/p&gt; 
&lt;p&gt;2.设备控制器一般包括控制器与主机的接口、控制器和设备的接口和控制器本身的I/O部分组成。控制器和主机的数据交换主要是通过数据线、地线和数据线相连。控制器中包含控制寄存器、状态寄存器和数据寄存器三类寄存器，用来存储需要完成的通信类型，I/O设备的状态和通信传输的数据。&lt;/p&gt; 
&lt;p&gt;3.I/O通道是一种特殊的处理机。它具有执行I/O指令的能力，并通过执行通道(I/O)程序来控制I/O操作。&lt;/p&gt; 
&lt;p&gt;4.按通道的工作方式，通道分为选择通道、字节多路通道和数组多路通道三种类型。&lt;/p&gt; 
&lt;p&gt;5.操作系统的I/O控制方式是指操作系统控制I/O设备执行I/O操作的方式，主要有程序直接控制方式、中断方式、DMA方式和通道控制方式。&lt;/p&gt; 
&lt;p&gt;6.缓冲的作用：&lt;br&gt; （1）解决基本数据单元大小（即数据粒度）不匹配的问题。&lt;br&gt; （2）提高CPU和I/O设备之间的并行性。&lt;/p&gt; 
&lt;p&gt;7.单缓冲：在设备和处理机之间设置一个缓冲区。设备和处理机交换数据时，先把被交换数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据。&lt;/p&gt; 
&lt;p&gt;8.双缓冲：I/O设备输入数据时先装填到缓冲区1，在缓冲区1填满后才开始装填缓冲区2，与此同时处理机可以从缓冲区1中取出数据放入用户进程处理，当缓冲区1中的数据处理完后，若缓冲区2已填满，则处理机又从缓冲区2中取出数据放入用户进程处理，而I/O设备又可以装填缓冲区1。双缓冲机制提高了处理机和输入设备的并行操作的程度。&lt;/p&gt; 
&lt;p&gt;9.多缓冲：多缓冲区包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。循环缓冲用于输入/输出时，还需要有两个指针in和out。&lt;/p&gt; 
&lt;p&gt;10.独占设备的分配&lt;/p&gt; 
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200704201501927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt; 
&lt;p&gt;11.独占设备分配&lt;br&gt; 表格有设备控制表（DCT）、控制器控制表（COCT）、通道控制表（CHCT）和系统设备表（SDT）&lt;/p&gt; 
&lt;p&gt;12.SPOOLing技术&lt;br&gt; SPOOLing系统主要有以下三部分：&lt;br&gt; 输入井和输出井。&lt;br&gt; 输入缓冲区和输出缓冲区。&lt;br&gt; 输入进程SPi和输出进程SPo。&lt;/p&gt; 
&lt;p&gt;13.SPOOLing系统具有如下主要特点：&lt;br&gt; （1）提高了I/O的速度。&lt;br&gt; （2）将独占设备改造为共享设备。&lt;br&gt; （3）实现了虚拟设备功能。&lt;/p&gt; 
&lt;hr&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第八章 文件管理&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/2020070418564667.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsNjIwMzIx,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt; 
&lt;p&gt;1.文件(File)是操作系统中的一个重要概念。 文件可以有如下定义：&lt;br&gt; (1) 文件是软件机构，软件资源的管理方式；&lt;br&gt; (2) 具有符号名的一组相关元素的有序序列，是一段程序或数据的集合；&lt;br&gt; (3) 一组赋名的相关联字符流的集合，或者是相关记录。而记录是有意义的信息集合。&lt;/p&gt; 
&lt;p&gt;2.文件的功能&lt;br&gt; （1）统一管理文件存储空间（即外存），实施存储空间的分配与回收&lt;br&gt; （2）确定文件信息的存放位置及存放形式&lt;br&gt; （3）实现文件从名字空间到外存地址空间的映射，实现文件的按名存取。&lt;br&gt; （4）有效实现对文件的各种控制操作和存取操作。&lt;br&gt; （5）实现文件信息的共享，并且提供可靠的文件保密和保护措施。&lt;/p&gt; 
&lt;p&gt;3.文件目录：一个计算机系统中有成千上万个文件，为了便于对文件进行存取和管理，计算机系统建立文件的索引，即文件名和文件物理位置之间的映射关系，这种文件的索引称为文件目录。&lt;/p&gt; 
&lt;p&gt;4.文件目录(file directory）为每个文件设立一个表目。&lt;br&gt; 文件目录（或称为文件夹）是由文件目录项组成的。文件目录分为一级目录、二级目录和多级目录。&lt;/p&gt; 
&lt;p&gt;5.文件分配的存储空间是辅存中的空闲空间，辅存中的空闲空间应该由操作系统统一进行管理，常用的方法主要有空闲表法、空闲链表法、位示图法和成组链接法。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;PS:以上内容非作者允许，禁止转载或者抄袭&lt;/p&gt; 
&lt;/blockquote&gt;
                &lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;
                &lt;link href=&#34;https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-d7a94ec6ab.css&#34; rel=&#34;stylesheet&#34;&gt;
                &lt;link href=&#34;https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-80ad9b4f5b.css&#34; rel=&#34;stylesheet&#34;&gt;
        &lt;/div&gt;
    &lt;/article&gt;">操作系统思维导图---（零基础---思维导图详细版本及知识点）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/lian-biao-gui-bing-tou-cha-fa/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://dm24530.GitHub.io/post-images/1613809559102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;
&lt;code&gt;
void merge(LNode *A, LNode *B, LNode *&amp;C)      // *&amp;C是新链表
{
    //待对比的指针 *p， *q
    LNode *p = A-&gt;next;
    LNode *q = B-&gt;next;
    LNode *s;      
    //只要其中一个头节点，然后将另外的释放
    C = A;
    C-&gt;next = NULL;
    free (B);
    while(p != NULL &amp;&amp; q != NULL)
    {
        if(p-&gt;data &lt;= q-&gt;data)
        {
            s = p; p = p-&gt;next;
           s-&gt;next = C-&gt;next; C-&gt;next = s;
        }
        else
        {
            //改为头插法
           s = q; q = q-&gt;next;
            s-&gt;next = C-&gt;next; C-&gt;next = s;
        }
    }
    if(p != NULL) 
    {
        s = p;
        p = p-&gt;next;
        s-&gt;next = C-&gt;next;
        C-&gt;next = s;
    }
    if(q != NULL)
    {
        s = q;
        q = q-&gt;next;
        s-&gt;next = C-next;
        C-&gt;next = s;
    }
}

&lt;/code&gt;
&lt;/pre&gt;">链表归并（头插法）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/lian-biao-gui-bing/"" data-c="
          &lt;pre&gt;
&lt;code&gt;
void mergearray(int a[ ], int m, int b[ ], int n, int c[ ])
{
    int i = 0, j = 0;
    int k = 0;
    while(i &lt; m &amp;&amp; j &lt; n)
    {
        if(a[i] &lt; b[j])
            c[k++] = a[i++];      //c[k] = a[i;]; k++; i++;
        else
            c[k++] = b[j++]
    }
    while(i &lt; m)
        c[k++] = a[i++];
    while(j &lt; n)
        c[k++] = b[j++];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;使用链表方法&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://dm24530.GitHub.io/post-images/1613808807916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;
&lt;code&gt;
void merge(LNode *A, LNode *B, LNode *&amp;C)      // *&amp;C是新链表
{
    //待对比的指针 *p， *q
    LNode *p = A-&gt;next;
    LNode *q = B-&gt;next;
    LNode *r;      //新链表尾指针
    //只要其中一个头节点，然后将另外的释放
    C = A;
    C-&gt;next = NULL;
    free (B);
    r = C;
    while(p != NULL &amp;&amp; q != NULL)
    {
        if(p-&gt;data &lt;= q-&gt;data)
        {
            r-&gt;next = p; p = p-&gt;next;
            r = r-&gt;next;      // r指向新结点尾部
        }
        else
        {
            r-&gt;next = q; q = q-&gt;next;
            r = r-&gt;next;
        }
    }
    if(p != NULL) 
        r-&gt;next = p;
    if(q != NULL)
        r-&gt;next = q;
}
&lt;/code&gt;
&lt;/pre&gt;">链表归并</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/cai-yong-dai-tou-jie-dian-de-dan-lian-biao-bao-cun-dan-ci/"" data-c="
          &lt;p&gt;假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间，例如，&amp;quot;loading 和&amp;quot;being的存储映像如下图所示。&lt;br&gt;
&lt;img src=&#34;https://dm24530.GitHub.io/post-images/1613807957762.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为{data, next}, 请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置(如图中字符i所在结点的位置p)。&lt;br&gt;
要求:&lt;br&gt;
1)给出算法的基本设计思想。&lt;br&gt;
2)根据设计思想，采用C或C++或JAVA语音描述算法，关键之处给出注释。&lt;br&gt;
3)说明你所设计算法的时间复杂度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
LNode *findFristCommon(LNode *str1, LNode *str2)
{
    int len1 = 0, len2 = 0;
    LNode *p = str1-&gt;next, *q = str2-&gt;next;
    while(p != NULL)
    {
        len1++;
        p = p-&gt;next;
    }
    while(q != NULL)
    {
        len2++;
        q = q-&gt;next;
    }
    for(p = str1-&gt;next; len1 &gt; len2; len1--)
        p = p-&gt;next;
    for(q = str2-&gt;next; len1 &lt; len2; len2--)
        q = q-&gt;next;
    while( p!= NULL &amp;&amp; p != q)
    {
        p = p-&gt;next;
        q = q-&gt;next;
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
">采用带头结点的单链表保存单词</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/lian-biao-zhao-zui-zhi/"" data-c="
          &lt;b&gt;
    一双链表非空，有head指针指出，结点结构为{llink, data, rlink}，请设计一个将节点数据域data值最大的那个结点（最大值结点只有一个）移动到链表最前边的算法，要求不得申请新节点空间
&lt;/b&gt;
&lt;pre&gt;
&lt;code&gt;
void maxFirst(DLNode *head)
{
    DLNode *p = head-&gt;rlink, *q = p;
    int max = p-&gt;data;
    // 找最值：
    while(p != NULL)
    {
        if(max &lt; p-&gt;data)
        {
            max = p-&gt;data;
            q = p;
        }
        p = p-&gt;rlink;
    }
    // ‘删除’：
    DLNode *l = q-&gt;llink, *r = q-&gt;rlink;
    l-&gt;rlink = r;
    if(r != NULL)
        r-&gt;llink = l;
    // 插入：
    q-&gt;llink = head;
    q-&gt;rlink = head-&gt;rlink;
    head-&gt;rlink = q;
    q-&gt;rlink-llink = q;
}
&lt;/code&gt;
&lt;/pre&gt;">链表找最值</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/zhong-zhui-zhuan-qian-zhui/"" data-c="
          &lt;pre&gt;
&lt;code&gt;
# infix [] -&gt; 中缀表达式 ； s2[] -&gt; 栈的顺序表 ； top2 -&gt; 栈顶指针 ； len表达式长度
void infixToPostFix(char infix[ ], char s2[ ], int &amp;top2, &lt;b&gt;int len&lt;/b&gt;)
{
    char s1[maxSize];       #s1辅助栈
    int top1 = -1;
    &lt;b&gt;int i = len-1;&lt;/b&gt;
   &lt;b&gt; while(i &gt;= 0)&lt;/b&gt;
    {
        if(&#39;0&#39; &lt;= infix[i] &amp;&amp; infix[i] &lt;= &#39;9&#39;)
        {
            s2[++top2] = infix[i];
            &lt;b&gt;--i;&lt;/b&gt;
        }
        else if(infix[i] == &#39;&lt;b&gt;)&lt;/b&gt;&#39; )
        {
            s1[++top1] = &#39;&lt;b&gt;)&lt;/b&gt;&#39;;
            &lt;b&gt; --i; &lt;/b&gt;
        }
        else if (infix[i] == &#39;+&#39; || infix[i] == &#39;-&#39; ||
                    infix[i] == &#39;*&#39; || infix[i] == &#39;/&#39;)
        {
            if(top1 == -1 || s1[top1] == &#39;&lt;b&gt;)&lt;/b&gt;&#39; ||      #当栈为空
                getPriority(infix[i]) &lt;b&gt;&gt;=&lt;/b&gt; getPriority(s1[top1]))     #当前优先级 &gt;= 栈顶优先级
            {
                s1[++top1] = infix[i];
                &lt;b&gt;--i;&lt;/b&gt;
            }
            else
                s2[++top2] = s1[top1--];      #将运算符入栈到s2中
        }
        else if(infix[i] == &#39;&lt;b&gt;(&lt;/b&gt;&#39;)      #当遇到左括号
        {
            while(s1[top1] != &#39;&lt;b&gt;)&lt;/b&gt;&#39;)
                s2[++top2] = s1[top1--];
            --top1;
            &lt;b&gt;--i;&lt;/b&gt;
        }
    }
    while(top1 != -1)
        s2[++top2] = s1[top--];
}
&lt;/code&gt;
&lt;/pre&gt;">中缀转前缀</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/04-05-zhong-zhui-zhuan-hou-zhui/"" data-c="
          &lt;pre&gt;
&lt;code&gt;
# infix [] -&gt; 中缀表达式 ； s2[] -&gt; 栈的顺序表 ； top2 -&gt; 栈顶指针
void infixToPostFix(char infix[ ], char s2[ ], int &amp;top2)
{
    char s1[maxSize];       #s1 辅助栈
    int top1 = -1;
    int i=0;
    while(infix[i] != &#39;\0&#39;)
    {
        if(&#39;0&#39; &lt;= infix[i] &amp;&amp; infix[i] &lt;= &#39;9&#39;)
        {
            s2[++top2] = infix[i];
            ++i;
        }
        else if(infix[i] == &#39;(&#39;)
        {
            s1[++top1] = &#39;(&#39;;
            ++i;
        }
        else if (infix[i] == &#39;+&#39; || infix[i] == &#39;-&#39; ||
                    infix[i] == &#39;*&#39; || infix[i] == &#39;/&#39;)
        { 
            if(top1 == -1 || s1[top1] == &#39;(&#39; ||      #当栈顶为空
                getPriority(infix[i]) &gt; getPriority(s1[top1]))      当前优先级 &gt; 栈顶优先级
            {
                s1[++top1] = infix[i];
                ++i;
            }
            else
                s2[++top2] = s1[top1--];      #将运算符入栈到s2中
        }
        else if(infix[i] == &#39;)&#39;)
        {
            while(s1[top1] != &#39;(&#39;)      #当遇到右括号时
                s2[++top2] = s1[top1--];
            --top1;
            ++i;
        }
    }
    while(top1 != -1)
        s2[++top2] = s1[top--];
}
&lt;/code&gt;
&lt;/pre&gt;">04-05 中缀转后缀</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/用栈求中缀表达式值/"" data-c="
          &lt;pre&gt; 
&lt;code&gt;
int getPriority(char op)      #判断运算符优先级
{
    if(op == &#39;+&#39; || op == &#39;-&#39;)
        return 0;
    else
        return 1; 
}

int calSub(float opand1, char op, float opand2, float &amp;result)       #子表达式求值
{
    if(op == &#39;+&#39;)  result = opand1+opand2;
    if(op == &#39;-&#39;)  result = opand1- opand2;
    if(op == &#39;*&#39;)  result = opand1 * opand2;
    if(op == &#39;/&#39;) 
    {
        if(fabs(opand2) &lt; MIN)     #fabs() 求绝对值，MIN几乎为零，对float是否为零的标准写法，不直接判断为零，而是用这种接近的方式
        {
            return 0;
        }
        else
        {
            result = opand1 / opand2;
        }
    }
    return 1;
}
//求解中缀表达式
float calInfix(char exp[ ])
{
    //定义两个栈并且初始化
    float s1[maxSize]; int top1 = -1;      //存操作数
    char s2[maxSize]; int top2 = -1;      //存运算符
    int i = 0;
    while(exp[i] != &#39;\0&#39;)      //‘\0&#39;为结束符
    {
        if(&#39;0&#39; &lt;= exp[i] &amp;&amp; exp[i] &lt;= &#39;9&#39;)
        {
            s1[++top1] = exp[i] - &#39;0&#39;;       //将字符型转换为数值型
            ++i;
        }
        else if(exp[i] == &#39;(&#39;)
        {
            s2[++top2] = &#39;(&#39;;
            ++i;
        }
        else if (exp[i] == &#39;+&#39; || exp[i] == &#39;-&#39; ||
                    exp[i] == &#39;*&#39; ||exp[i] == &#39;/&#39;  )
        {
            if(top2 == -1 || s2[top2] == &#39;(&#39; || getPriority(exp[i]) &gt; getPriority(s2[top2]))//当栈空或为左括号或当前优先级&gt;栈顶优先级时入栈
            {
                s2[++top2] = exp[i];
                ++i;
            }
            else
            {
               int flag = calStackTopTwo(s1, top1, s2, top2);
               if(flag == 0)
                return 0;
            }
        }
        else if(exp[i] == &#39;)&#39;)
        {
            while(s2[top2] != &#39;(&#39;)
            {
                 int flag = calStackTopTwo(s1, top1, s2, top2);
                 if(flag == 0)
                return 0;
            }
            --top2;
            ++i;
        }
    }
    while(top2 != -1)
    {
         int flag = calStackTopTwo(s1, top1, s2, top2);
         if(flag == 0)
                return 0;
    }
    return s1[top1];
}
//将重复的部分写成函数
int calStackTopTwo(float s1[ ], int &amp;top1, char s2[ ], int &amp;top2)
{
     float opand1, opand2, result;      //opand1, opand2接收出栈操作数，result是运算符结果
                char op;      //运算符
                int flag;
                opand2  = s1[top1--];
                opand1 = s1[top1--];
                op = s2[top2--];
                flag = calSub(opand1, op, opand2, result);
                if(flag == 0) {
                    &lt;span&gt;std::count&lt;&lt;&#34;ERROR&#34;&lt;&lt;&lt;/span&gt;std::end1;     //puts(&#34;ERROR&#34;);
                }  
                s1[++top1] = result;
                return flag;
}

//
&lt;/code&gt;
&lt;/pre&gt; 
">04-06用栈求中缀表达式值</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/1ji-chu-liu-cheng/"" data-c="
          &lt;h2&gt;任务&lt;/h2&gt;
&lt;h3&gt;1.新建工程文件&lt;/h3&gt;
&lt;h3&gt;2.导入素材文件&lt;/h3&gt;
&lt;h3&gt;3.对素材进行编辑&lt;/h3&gt;
&lt;h3&gt;4.完成输出&lt;/h3&gt;
&lt;hr&gt;
&lt;h3&gt;1.新建工程文件&lt;/h3&gt;
启动pr软件，在欢迎界面上点击“新建项目”按钮
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593783163797.png?raw=true&#34;&gt;
打开“新建项目”对话框新建一个工程文件
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593783167242.png?raw=true&#34;&gt;
&lt;h3&gt;2.导入素材文件&lt;/h3&gt;
选择编辑界面
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593783575397.png?raw=true&#34;&gt;
点击项目中的新建项，序列，创建一个序列
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593784085555.png?raw=true&#34;&gt;
右键点击空白处，选择导入我们想要的图片，同样的方法导入音频（点击左上角文件、导入也可以）
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593784311918.png?raw=true&#34;&gt;
这个就是我导入成的样子
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593784442349.png?raw=true&#34;&gt;
&lt;h3&gt;3.对素材进行编辑&lt;/h3&gt;
将图片拉入到左边我们刚刚创建的序列01中
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593784617019.png?raw=true&#34;&gt;
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593784846692.png?raw=true&#34;&gt;
我们发现音频多出来了一部分，现在我们就把这一部分去掉
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593785304384.png?raw=true&#34;&gt;
这时候我们点击播放就可以看到这个视频已经完整了
如果我们想要加入自己的特征文字之类的可以
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593785679500.png?raw=true&#34;&gt;
是不是加入之后感觉不好看
点击上边栏中的窗口、基本图形，选择编辑，选择自己想要更改的文本，然后编辑
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593785965518.png?raw=true&#34;&gt;
&lt;h3&gt;4.完成输出&lt;/h3&gt;
弄完之后就可以点击上方文件、导出、媒体
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593786259910.png?raw=true&#34;&gt;
这样就大功告成了，一个简单的视频就做成了">1.基础流程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/tong-guo-github-da-jian-yi-ge-zi-ji-de-wang-zhan/"" data-c="
          &lt;h2&gt;一、注册或登录GitHub账号&lt;h2&gt;
&lt;pre&gt;GitHub网站：&lt;a href=&#34;https://github.com/&#34;&gt;https://github.com/&lt;/a&gt;&lt;/pre&gt;
&lt;h2&gt;二、创建一个库&lt;/h2&gt;
&lt;img src=&#34;https://github.com/dm24530/dm24530.github.io/blob/master/post-images/1593745472784.png?raw=true&#34;&gt;">通过GitHub搭建一个自己的网站</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/25-chuang-jian-numpy-shu-zu/"" data-c="
          &lt;p&gt;有多种方法可以用创建NumPy数组，下面是其中的一些方法：&lt;/p&gt;
&lt;p&gt;♦将现有的数据结构转换成数组。&lt;/p&gt;
&lt;p&gt;♦新创建一个数组，使用默认值或计算值填充它。&lt;/p&gt;
&lt;p&gt;♦从磁盘加载一些数据到数组&lt;/p&gt;
&lt;p&gt;如果想转换现有的数据结构，其关键就在于使用的数据结构是结构化的列表还是pandas数据框。&lt;/p&gt;
">2.5 创建NumPy数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/251-cong-lie-biao-dao-yi-wei-shu-zu/"" data-c="
          &lt;p&gt;进行转换操作时，重要的是考虑列表中包含的对象，这将决定结果数组的维数和类型。import numpy as np&lt;/p&gt;
&lt;h1 id=&#34;transform-a-list-into-a-uni-dimensional-array&#34;&gt;Transform a list into a uni-dimensional array&lt;/h1&gt;
&lt;h1 id=&#34;定义一个列表&#34;&gt;定义一个列表&lt;/h1&gt;
&lt;p&gt;list_of_ints = [1,2,3]&lt;/p&gt;
&lt;h1 id=&#34;nparray将列表转换成数组&#34;&gt;np.array将列表转换成数组&lt;/h1&gt;
&lt;p&gt;Array_1 = np.array(list_of_ints)&lt;br&gt;
Array_1&lt;/p&gt;
&lt;p&gt;注意：可以像标准的python列表那样访问一维数组（索引从零开始）&lt;/p&gt;
&lt;p&gt;例如:Array_1[1]&lt;/p&gt;
&lt;p&gt;我们可以查看对象及其元素的类型等更多的信息&lt;/p&gt;
&lt;p&gt;查看数据结构的对象类型：type(Array_1)&lt;/p&gt;
&lt;p&gt;查看数组中每个元素的类型：Array_1.dtype  (默认的dtype属性取决于使用的操作系统)&lt;/p&gt;
">2.5.1 从列表到一维数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/252-kong-zhi-nei-cun-da-xiao/"" data-c="
          &lt;p&gt;如果数值范围有限，使用int32值类型来表示，你也许会认为是一种内存浪费。&lt;/p&gt;
&lt;p&gt;事实上，可以使用计算Array_1对象的内存占用情况：&lt;/p&gt;
&lt;p&gt;import numpy as np&lt;/p&gt;
&lt;h1 id=&#34;nbytes查看内存占用情况&#34;&gt;nbytes查看内存占用情况&lt;/h1&gt;
&lt;p&gt;Array_1.nbytes&lt;/p&gt;
&lt;p&gt;注意：32位和64位结果不一样&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;为了节省内存，可以事先为所使用的数组指定最合适的类型：&lt;/p&gt;
&lt;p&gt;Array_1 = np.array(list_of_ints, dtype= &#39;int8&#39;)&lt;br&gt;
Array_1.nbytes&lt;/p&gt;
&lt;p&gt;数组内存占用空间只有之前的四分之一&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果想改变一个数组的类型，通过一下命令可以给轻松指定新的数据类型：&lt;/p&gt;
&lt;p&gt;Array_1b = Array_1.astype(&#39;float32&#39;)&lt;br&gt;
Array_1b&lt;/p&gt;
&lt;p&gt;.astype() 方法总是创建一个新的数组，所以要注意数组的内存消耗&lt;/p&gt;
">2.5.2 控制内存大小</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/551-zhong-duan-de-gai-nian/"" data-c="
          &lt;p&gt;计算机在执行程序的过程中，当出现异常情况，或者特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再2返回到现行程序的间断处，继续执行原程序，这就是“中断”。&lt;/p&gt;
&lt;p&gt;中断是现代计算机能有效合理地发挥效能和提高效率的一种十分重要的功能。&lt;/p&gt;
">5.5.1 中断的概念</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/552-io-zhong-duan-de-chan-sheng/"" data-c="
          &lt;p&gt;在I/0设备与主机交换信息时,由于设备本身机电特性的影响,其工作速度较低,与CPU无法匹配,因此,CPU启动设备后,往往需要等待一段时间才能实现主机与I/0设备之间的信息交换。如果在设备准备的同时,CPU不作无谓的等待,而继续执行现行程序,只有当I/0设备准备就绪向CPU提出请求后,再暂时中断CPU现行程序转人I/0服务程序,这便产生了I/O 中断。&lt;/p&gt;
">5.5.2  I/O中断的产生</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/553-cheng-xu-zhong-duan-fang-shi-de-jie-kou-dian-lu/"" data-c="
          &lt;p&gt;1.中断请求触发器和中断屏蔽触发器&lt;/p&gt;
&lt;p&gt;中断请求触发器INTR，中断屏蔽触发器MASK&lt;/p&gt;
&lt;p&gt;当多个中断源向CPU提出中断请求时，CPU必须坚持一个原则，即在任何瞬间只能接受一个中断源的请求。CPU对各中断源的请求进行排队，只接受级别最高的中断源请求&lt;/p&gt;
&lt;p&gt;当MASK为“1”时，表示被屏蔽，即封锁其中断源的请求，仅当设备准备就绪，且该设备未被屏蔽(MASK=0)，CPU的中断查询信号可将中断请求触发器置“1”(INTR=1)&lt;/p&gt;
&lt;p&gt;中断请求触发器和中断屏蔽触发器在I/O接口中时成对出现的。&lt;/p&gt;
&lt;p&gt;CPU总是在每条指令执行阶段的最后时刻，查询所有的设备是否有中断请求。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;2.排队器&lt;/p&gt;
&lt;p&gt;设备优先权的处理可以采用硬件方法，也可以采用软件方法。硬件排队器的实现方法很多，即可在CPU内部设置一个统一的排队器，对所有中断源进行排队，也可在接口电路内分别设置各个设备的排队器，又称链式排队器。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;3.中断向量地址形成部件（设备编码器）&lt;/p&gt;
&lt;p&gt;不同的设备有不同的中断服务程序，每个服务程序都有一个入口地址，CPU必须找到这个入口地址。&lt;/p&gt;
&lt;p&gt;入口地址的寻找也可以用硬件或软件的方法来完成。所谓的硬件向量法，就是通过向量地址来寻找设备的中断服务程序入口地址，而且向量地址是由硬件电路产生的。&lt;/p&gt;
&lt;p&gt;中断向量地址形成部件的输入是来自排队器中的输出INTP¡,它的输出是中断向量（二进制代码表示），其位数与计算机可以处理中断源的个数有关，即一个中断源对应一个向量地址。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;4.程序中断方式接口电路的基本组成&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
">5.5.3  程序中断方式的接口电路</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/253-yi-gou-lie-biao/"" data-c="
          &lt;p&gt;如果列表由多种类型组成，输出列表元素类型时倾向于更普遍和精度更高的类型。浮点型较整型占优，字符串又较整型，浮点型占优。&lt;/p&gt;
&lt;p&gt;在使用列表创建数组时，可以混用不同元素。可以通过查询结果数组的dtype来检查列表元素类型。&lt;/p&gt;
&lt;p&gt;如果使用不确定数组的内容，确实必须检查数组类型，否则，以后可能无法对结果数组进行某些特定的操作。使用isinstance()查看数据类型。&lt;/p&gt;
&lt;p&gt;print (isinstance(Array_2[0],np.number))&lt;/p&gt;
&lt;p&gt;列表中对象类型也会影响数组的维数&lt;/p&gt;
">2.5.3 异构列表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/254-cong-lie-biao-dao-duo-wei-shu-zu/"" data-c="
          &lt;p&gt;如果把包含数值或者文本的列表描述成一维数组（如系数向量），那么，列表的列表就可以转换成二维数组，列表的列表的列表就是三维数组。&lt;/p&gt;
&lt;p&gt;a_list_of_lists = [[1,2,3],[4,5,6],[7,8,9]]&lt;br&gt;
a_list_of_lists&lt;br&gt;
Array_2D = np.array(a_list_of_lists )&lt;br&gt;
Array_2D&lt;/p&gt;
&lt;p&gt;np.array()将列表直接转换成数组。在列表中可以使用索引调用单个数值，这个我们要用两个索引，一个行维度（也称为轴0），一个列维度（轴1）&lt;/p&gt;
&lt;p&gt;Array_2D[1,1]    输出的结果为5&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;通过嵌套列表实现三维数组&lt;/p&gt;
&lt;p&gt;a_list_of_lists_of_lists = [[[1,2],[3,4],[5,6]],&lt;br&gt;
[[7,8],[9,10],[11,12]]]&lt;br&gt;
a_list_of_lists_of_lists&lt;br&gt;
Array_3D = np.array(a_list_of_lists_of_lists)&lt;br&gt;
Array_3D&lt;/p&gt;
&lt;p&gt;要访问三维数组的单个元素，需要指定有三个索引的元组：&lt;/p&gt;
&lt;p&gt;Array_3D[0,2,0]     输出的结果是5&lt;/p&gt;
">2.5.4 从列表到多维数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/255-numpy-shu-ju-chu-li/"" data-c="
          &lt;p&gt;对于加载的数据，必须进行进一步的处理，为后继的监督学习和无监督学习过程准备合适的数据矩阵。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个阶段：数据是异质数据时（数据类型时数字和符号的混合）&lt;/li&gt;
&lt;li&gt;第二个阶段：数据为数值表格，表中的行表示实例，列表示实例的观测特征，也就是变量&lt;br&gt;
Pandas中有两种数据类型：Series和数据框（DataFrame）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Numpy中的N维数组（ndarray）&lt;/strong&gt;&lt;br&gt;
√python中列表可以按顺序存储异质对象&lt;br&gt;
√python中字典允许访问复杂内容，多维数组的数据结构&lt;/p&gt;
&lt;p&gt;&lt;b&gt;字典和列表的局限性体现在：&lt;/b&gt;&lt;br&gt;
&lt;strong&gt;·&lt;/strong&gt; 存在内存和速度方面问题（python自带的数据结构不是使用连续的内存块优化的）&lt;br&gt;
&lt;strong&gt;·&lt;/strong&gt; python存储的数据结构善于存储数据却不善于操作数据（处理数据时，必须先定义函数，对列表和字典元素进行迭代或映射，不适用于大数据处理）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ndarray类的属性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存最优（以内存块的最佳布局传送数据）&lt;/li&gt;
&lt;li&gt;允许快速线性代数计算（矢量），不需要使用for循环迭代就能进行逐元素的操作&lt;/li&gt;
&lt;li&gt;是Scipy和Scikit-learn等重要库的数据结构，作为它们函数的输入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ndarray对象具有以下缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常存储单一的，事先定义好的特定数据类型&lt;/li&gt;
&lt;li&gt;初始化之后，数组的大小就固定了&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Numpy  ndarray对象基础&lt;/strong&gt;&lt;br&gt;
◊ python中，数组本质上是一组特定类型的内存相邻的元素，数据标题包含索引机制和数据类型描述符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于索引机制，数组能够表示多维数据结构，每个元素由n个整数组成的原组索引，其中n是维数&lt;/li&gt;
&lt;li&gt;如果是一维数组（顺序数据形成的矢量），索引将从零开始（就像Python列表一样）&lt;/li&gt;
&lt;li&gt;如果是二维数组，必须采用两个整数作为索引（包含坐标x , y的元组）&lt;/li&gt;
&lt;li&gt;如果数据中有三个维度，索引将使用三个整数（包含x , y , z的元组）&lt;/li&gt;
&lt;li&gt;如此类推......&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;◊Python中，数组在每个索引位置，数组存储指定类型的数据，且数组从一开始就确定类型，根据类型来分配内存空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组创建程序可以保留确切的内存空间以存储所有的数据。&lt;/li&gt;
&lt;li&gt;尽管数组的大小固定，也不能在结构上发生变化，数组元素的访问、修改和计算却变得相当快速。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;◊Numpy数组缺点 是不方便数据更改，插入或删除数据时需要重新创建一个数组。&lt;/p&gt;
&lt;p&gt;◊列表数据结构在表示多维数据时，只能将自己转换成嵌套列表,导致访问数据增加时间开销和内存碎片。&lt;br&gt;
➢查看数组，数据结构中的数据转换成其他形式，但源数组不变;&lt;br&gt;
➢复制数组，创建了一个具有不同结构的新数组&lt;br&gt;
◊Pandas所有的数据框实际上都是由一-维 的Numpy数组组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按列操作，每列都是一-个Numpy数组，继承了ndarray快速和高效的内存&lt;/li&gt;
&lt;li&gt;按行操作，需要访问不同的列，即不同的Numpy数组&lt;/li&gt;
&lt;li&gt;Numpy数组使用整数作为位置索引，pandas索 引需要将索引转换成对应的位置再操作&lt;br&gt;
√位置索引比pandas索引速度快&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;创建Numpy数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有多种方法可以用来创建NumPy数组:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将现有的数据结构转换成数组&lt;/li&gt;
&lt;li&gt;新创建一个数组，使用默认值或计算值填充它&lt;/li&gt;
&lt;li&gt;从磁盘加载一些数据到数组&lt;br&gt;
注:如果想转换现有的数据结构，其关键就在于使用的数据结构是结构化的列表还是pandas数据框&lt;/li&gt;
&lt;/ul&gt;
">2.5.5  Numpy数据处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/262-numpy-shu-zu-qie-pian-he-suo-yin/"" data-c="
          &lt;p&gt;通过指定可视化的行，列切片或索引值，可以对ndarray数组进行观测&lt;br&gt;
首先，定义一个十行五列的工作数组：&lt;br&gt;
import numpy as np&lt;br&gt;
dataset = np.arange(10*5).reshape(10,5)&lt;br&gt;
dataset&lt;br&gt;
（shape()是array的属性，查看数据有多少行，多少列。&lt;br&gt;
reshape()是数组array中的方法，作用是将数组重新组织）&lt;/p&gt;
&lt;p&gt;◊ &lt;strong&gt;提取数组中第2~8行的偶数行&lt;/strong&gt;：&lt;br&gt;
dataset[2:9:2,:]&lt;/p&gt;
&lt;p&gt;◊ &lt;strong&gt;还可以进一步进行列切片，提取第3列以后的数据&lt;/strong&gt;&lt;br&gt;
dataset[2:9:2,2:]&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;&lt;strong&gt;列索引从第3（索引2）列开始，逆序取值直到第1列（索引0）&lt;/strong&gt;&lt;br&gt;
dataset[2:9:2,2::-1]&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;&lt;strong&gt;可以创建布尔索引，指示选择哪一列或哪一行&lt;/strong&gt;&lt;br&gt;
例如：选择20&amp;lt;=行&amp;lt;=40 ,列&amp;gt;=2&lt;br&gt;
row_index = (dataset[:,0]&amp;gt;=20)&amp;amp;(dataset[:,0]&amp;lt;=40)&lt;br&gt;
col_index = dataset[0,:]&amp;gt;=2&lt;br&gt;
dataset[row_index,:][:,col_index]  (逻辑数组不能放在同一个[]中)&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;&lt;strong&gt;如果需要对数组进行全局选择，也可以使用布尔掩膜&lt;/strong&gt;：&lt;br&gt;
mask = (dataset&amp;gt;=20)&amp;amp;(dataset&amp;lt;=40)&amp;amp;((dataset/10.)%1&amp;gt;=0.2)&lt;br&gt;
dataset[mask]&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;&lt;strong&gt;另一种选择数组指定元素的方法是花式索引，利用元素所在行、列组成的整数数组进行索引&lt;/strong&gt;&lt;br&gt;
row_index = [1,1,2,4]&lt;br&gt;
col_index = [0,2,4,8]&lt;br&gt;
dataset[row_index,col_index]&lt;br&gt;
这样就会选择出坐标（1，0）、（1，2）、（2，4）、（4，8）位置处的元素&lt;/p&gt;
&lt;p&gt;最后，需要切记的是切片和索引只是数据的观测，如果需要对这些观测创建新的数据，则必须使用.copy方法将切片数据赋给另一个变量。否则，任何对原数组的修改都将反映到切片数据上。&lt;/p&gt;
">2.6.2  NumPy数组切片和索引</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/263-numpy-shu-zu-dui-die/"" data-c="
          &lt;p&gt;使用NumPy函数快速完成增加数据和变量等常见操作。&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;首先创建一个数组：&lt;br&gt;
import numpy as np&lt;br&gt;
dataset = np.arange(10*5).reshape(10,5)&lt;br&gt;
dataset&lt;/p&gt;
&lt;p&gt;◊ 创建一个单行数据和多行数据，用来与原来数据相连接：&lt;br&gt;
single_line = np.arange(1&lt;em&gt;5).reshape(1,5)&lt;br&gt;
a_few_lines = np.arange(3&lt;/em&gt;5).reshape(3,5)&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;vstack()命令只需要提供一个参数元组，元组包含两个需要连接的垂直数组，把第二个数组增加到第一个数组后边&lt;br&gt;
先来添加一行数据：&lt;br&gt;
np.vstack((dataset,single_line))&lt;br&gt;
增加多行数据：&lt;br&gt;
np.vstack((dataset,a_few_lines))&lt;br&gt;
如果需要多次增加单行数据，元组可以表示成新级联数组的顺序结构：&lt;br&gt;
np.vstack((dataset,single_line,single_line))&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;hstack()给现有数组增加变量，添加列&lt;br&gt;
创建一个10行1列全是1的数组&lt;br&gt;
bias = np.ones(10).reshape(10,1)&lt;br&gt;
按列添加&lt;br&gt;
np.hstack((dataset,bias))&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;dstack()函数类似于hstack()和vstack()，但它在进行第三轴数据操作时非常方便：&lt;br&gt;
np.dstack((dataset&lt;em&gt;1,dataset&lt;/em&gt;2,dataset*3))&lt;br&gt;
这个例子中，三维数据时原始二维数据的倍数，呈现累进变化率&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;Insert命令需要确定如下参数，数据要插入的数组（dataset），插入的位置（3），要插入的数据序列（bias），以及插入数据操作的数据轴（这里axis=1表示垂直轴，按列插入）&lt;br&gt;
np.insert(dataset, 3, bias, axis=1)&lt;/p&gt;
">2.6.3 NumPy数组堆叠</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/63-shu-ju-qing-li/"" data-c="
          &lt;p&gt;&lt;strong&gt;数据清理&lt;/strong&gt;&lt;br&gt;
◊ 格式标准化&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 异常数据清理&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 错误数据纠正&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 重复数据清除&lt;/p&gt;
&lt;p&gt;数据清洗是数据预处理的首要方法。通过填充缺失的数据值，光滑噪音数据，识别和删除群点，纠正数据不一致等方法，从而达到纠正错误，标准化数据格式，清除异常和重复数据的目的。&lt;/p&gt;
&lt;p&gt;缺失值的处理方法：&lt;br&gt;
1.忽略元组&lt;br&gt;
2.人工填写缺失值&lt;br&gt;
3.使用一个全局常量填充缺失值&lt;br&gt;
4.使用属性的中心度量（如均值或中位数）填充缺失值&lt;br&gt;
5.使用同类样本的属性均值或者中位数填充缺失值&lt;br&gt;
6.使用最可能的值填充缺失值&lt;/p&gt;
">6.3 数据清理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/64-shu-ju-ji-cheng/"" data-c="
          &lt;p&gt;&lt;strong&gt;数据集成&lt;/strong&gt;&lt;br&gt;
◊ 集成多源数据&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;建立数据仓库&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;ETL&lt;br&gt;
数据挖掘通常需要数据集成，即将多个数据源中的数据合并，存放于一个一致的数据存储中。在数据集成过程中，模式集成和对象匹配、冗余问题、元组属性以及数据值冲突的检测与处理都是需要重点考虑的问题。&lt;/p&gt;
&lt;p&gt;冗余问题是数据集成的另外一个需要考虑的重要问题，如果一个属性能由另外一个或几个属性“导出”，那么这个属性就是冗余。&lt;br&gt;
冗余问题可以通过相关性分析检测得到。对于标称数据，可以使用卡方检验检测属性之间的相关性；对于数值属性，可以利用相关系数和协方差等方法来评估一个属性的值如何随着另外一个属性值变化。&lt;/p&gt;
&lt;p&gt;卡方检测数值越大说明假设有问题，即两者相关性强，有冗余&lt;br&gt;
协方差Cov()&amp;gt;0,说明两者相关&lt;/p&gt;
">6.4  数据集成</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/65-shu-ju-gui-yue/"" data-c="
          &lt;p&gt;&lt;strong&gt;数据归约&lt;/strong&gt;&lt;br&gt;
◊ 尽可能保持原貌&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;缩短数据规模&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;特征降维&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊ &lt;/span&gt;特征选择&lt;br&gt;
经典的数据归约策略包括维归约，数量归约和数据压缩&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/jfdwd/p/9249850.html&#34;&gt;小波变换&lt;/a&gt;可以用于多维数据、指纹图像压缩、计算机视觉、时间序列数据分析和数据清理&lt;br&gt;
主成分分析，计算协方差矩阵 （体现相关性）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主成分分析&lt;/strong&gt;&lt;br&gt;
◊ 计算协方差均值&lt;br&gt;
◊ 特征值&lt;br&gt;
◊ 特征向量&lt;br&gt;
根据降维需求，选取最大特征值对应的特征向量，转置后和源数据矩阵的转 置相乘。最终实现了多维数据降维&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;属性子集选择&lt;/strong&gt;&lt;br&gt;
Δ 属性子集选择：选择最具区分度的属性集，实现降维&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他数据归约方法&lt;/strong&gt;&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;Δ&lt;/span&gt; 回归：使用函数拟合数据&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;Δ&lt;/span&gt; 直方图：使用直方图归约数据&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;Δ&lt;/span&gt; 聚类&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;Δ&lt;/span&gt; 抽样：无放回简单随机、有放回简单随机、簇抽样、分层抽样&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;Δ&lt;/span&gt; 数据立方体&lt;/p&gt;
">6.5 数据归约</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/66-shu-ju-bian-huan/"" data-c="
          &lt;p&gt;&lt;strong&gt;数据变换&lt;/strong&gt;&lt;br&gt;
◊ 平滑聚集&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 数据概化&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 规范化&lt;br&gt;
数据交换是将数据变换或统一成适合数据挖掘的形式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据规范化&lt;/strong&gt;&lt;br&gt;
平衡权重&lt;br&gt;
消除不同数值属性之间的绝对值差异&lt;/p&gt;
">6.6 数据变换</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/26-numpy-kuai-su-cao-zuo-he-ji-suan/"" data-c="
          &lt;p&gt;当参与运算的数值大小不同时，如果数组的维度是1，则不必进行数据重构仍然有可能进行按位操作。这种情况下，维数为1的维度要进行拉伸，直到它的维数与相应的数组的维度相匹配，这种转换称为广播机制。&lt;/p&gt;
&lt;p&gt;另外一些常用的NumPy()函数是sum()和prod()，它们在数组特定坐标轴上分别进行求和与乘积运算&lt;/p&gt;
&lt;p&gt;%time函数可以获得代码运行的基准测试时间。其中，参数-n 1表示代码片段只需要执行一次；参数-r 3表示需要重复执行循环3次&lt;br&gt;
例：%timeit -n 1 -r 3 [i+1.0 for i in range(10**6)]&lt;br&gt;
标准python运算比NumPy运算慢&lt;/p&gt;
">2.6 NumPy快速操作和计算</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/shu-ju-ke-xue-liu-cheng/"" data-c="
          &lt;p&gt;本章中，将学到如下内容：&lt;br&gt;
◊ 简要探索数据并创建新的特征&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 数据维度约简&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 异常数据的检测和处理&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 确定项目最合适的评分和损失指标&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 运用科学方法论，有效检验机器学习假设的性能&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 选择合适的特征集合&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;◊&lt;/span&gt; 优化学习参数&lt;/p&gt;
">数据科学流程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/31-eda-jian-jie/"" data-c="
          &lt;p&gt;EDA的主要工作是：对数据进行清洗，对数据进行描述（描述统计量，图表），查看数据的分布，比较数据之间的关系，培养对数据的直觉，对数据进行总结等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“探索性”指分析者对待解问题的理解会随着研究的深入不断变化&lt;br&gt;
基本步骤：&lt;br&gt;
A. 检查数据&lt;br&gt;
B. 使用描述统计量和图表对数据进行描述&lt;br&gt;
C. 考察变量之间的关系&lt;br&gt;
D. 检验特征分布&lt;br&gt;
E. 其他&lt;br&gt;
数据类型分为数值型，类别型，文本型，时间序列等。&lt;br&gt;
注：主要考虑数值型（定量数据）和类别型（定性数据）；数值型又可以分为连续型和离散型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;describe()&lt;/strong&gt; 生成描述型统计数据&lt;br&gt;
总结数据分布的集中趋势、分散和形状，不包括 NaN值。&lt;br&gt;
shape[0] 观测值的数量&lt;br&gt;
mean() 平均值&lt;br&gt;
std() 标准差&lt;br&gt;
min() 最小值&lt;br&gt;
quantile(0.25) 1/4分位数&lt;br&gt;
median() 中位数&lt;br&gt;
quantile(0.75) 3/4分位数分位数&lt;br&gt;
max() 最大值&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/wyy1480/p/9526264.html&#34;&gt;&lt;strong&gt;boxplot() &lt;/strong&gt;&lt;/a&gt; 箱线图&lt;br&gt;
特征去重复统计：unique()&lt;br&gt;
去除一维数组或列表中重复的元素，并按元素由大到小返回一个新的无元素重复的元组或者列表&lt;span style=&#34;background-color: #ffffff; color: #333333; display: inline; float: none; font-family: &amp;amp;quot; noto serif&amp;amp;quot;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;&lt;br&gt;
比如需要10%和90%两个分位数结果可以使用这个方法：&lt;/span&gt;&lt;br&gt;
&lt;span style=&#34;background-color: #ffffff; color: #333333; display: inline; float: none; font-family: &amp;amp;quot; noto serif&amp;amp;quot;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;iris.quantile([0.1, 0.9])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/rachelross/p/10468589.html&#34;&gt;&lt;strong&gt;crosstab()&lt;/strong&gt;&lt;/a&gt; 共生矩阵/交叉表&lt;br&gt;
用于统计分组频率的特殊透视表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scatter&lt;/strong&gt;：散点图&lt;br&gt;
散点图：scatter&lt;br&gt;
X轴： petal_width&lt;br&gt;
Y轴： petal_length&lt;br&gt;
颜色：blue&lt;br&gt;
边缘颜色：white&lt;br&gt;
散点直径: s&lt;br&gt;
使用案例：&lt;br&gt;
scatterplot = iris.plot(kind=&#39;scatter&#39;, x=&#39;petal_width&#39;, y=&#39;petal_length&#39;, s=64, c=&#39;blue&#39;, edgecolors=&#39;white&#39;)&lt;/p&gt;
&lt;p&gt;hist:直方图&lt;br&gt;
bin：直方图的分箱&lt;br&gt;
根据经验法则，bin的初始值是观测数量的平方根；&lt;br&gt;
在此基础上根据实际数据进行修正。&lt;br&gt;
使用案例：&lt;br&gt;
distr = iris.petal_width.plot(kind=&#39;hist&#39;, alpha=0.5, bins=20)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;EDA总结：&lt;/strong&gt;&lt;br&gt;
&lt;span style=&#34;color: #0000ff;&#34;&gt;- pandas读取数据集，显示前5行确认是否加载正确&lt;/span&gt;&lt;br&gt;
必要时对列名重命名&lt;br&gt;
&lt;span style=&#34;color: #0000ff;&#34;&gt;- 查看数据整体情况&lt;/span&gt;&lt;br&gt;
行列数data.shape，数据类型data.dtypes&lt;br&gt;
data.info()同时查看这两项&lt;br&gt;
data.describe()查看连续变量的描述统计量&lt;br&gt;
&lt;span style=&#34;color: #0000ff;&#34;&gt;- 处理缺失值，异常值，重复值问题&lt;/span&gt;&lt;br&gt;
各列分别有多少缺失值data.apply(lambda x: sum(x.isnull()),axis=0)&lt;br&gt;
各行分别有多少缺失值data.apply(lambda x: sum(x.isnull()),axis=1)&lt;br&gt;
总共有多少行有缺失值&lt;br&gt;
len(data.apply(lambda x: sum(x.isnull()),axis=1).nonzero()[0])&lt;br&gt;
删除重复值data.drop_duplicates()&lt;br&gt;
&lt;span style=&#34;color: #0000ff;&#34;&gt;- 分析特征之间相关性&lt;/span&gt;&lt;br&gt;
&lt;span style=&#34;color: #0000ff;&#34;&gt;- 检验数据分布&lt;/span&gt;&lt;/p&gt;
">3.1 EDA简介</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/32-te-zheng-chuang-jian/"" data-c="
          &lt;p&gt;当特征和目标变量并不是很相关时，可以修改输入的数据集，应用线性、非线性变换（或者其他相似方法）来提高系统的精度。&lt;br&gt;
-  数据是“死”的，人的思维是“活”的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据科学家负责改变数据集和输入数据，使数据更好地符合分类模型。&lt;br&gt;
&lt;strong&gt;基本方法：&lt;/strong&gt;&lt;br&gt;
A. 特征的线性修正&lt;br&gt;
B. 特征的非线性修正&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;♦ 计算均方差&lt;/strong&gt;&lt;br&gt;
均方差（Mean Squared Error，MSE）是参数估计值与真实值之差的平方的期望值。MSE的值越小，说明预测模型描述实验数据的准确度更好。&lt;br&gt;
&lt;strong&gt;♦ &lt;/strong&gt;&lt;strong&gt;平均绝对误差&lt;/strong&gt;&lt;br&gt;
平均绝对误差（Mean Absolute Error，MAE）是所有单个观测值与算术平均值的偏差的绝对值的平均。&lt;br&gt;
其中需要对训练数据进行标准化，标准化属于线性变化&lt;br&gt;
&lt;strong&gt;♦ &lt;/strong&gt;&lt;strong&gt;计算均方误差——Z-scores 标准化&lt;/strong&gt;&lt;br&gt;
Z-scores标准化是将特征映射为均值为0、标准差为1的新特征，即使原始数据转换为无量纲化值，即各指标值都处于同一数量级别。&lt;br&gt;
标准化后，均方差值减小一半。&lt;br&gt;
Z-scores 标准化属于线性变换。&lt;br&gt;
&lt;strong&gt;♦ &lt;/strong&gt;&lt;strong&gt;计算均方误差——鲁棒性缩放&lt;/strong&gt;&lt;br&gt;
鲁棒性缩放（RobustScaler）采用中位数和IQR对每个特征进行单独缩放。IQR：第一个和第三个四分位数。&lt;br&gt;
由于数据读入缺失、传输错误或传感器损坏等原因，如果有一个或一些点远离中心，这些异常数据对均值和方差的影响较大，但对中位数和四分位数影响不大，因此鲁棒缩放对于异常值更鲁棒。&lt;br&gt;
鲁棒缩放属于线性变换。&lt;br&gt;
&lt;strong&gt;♦ &lt;/strong&gt;&lt;strong&gt;特征非线性修正&lt;/strong&gt;&lt;br&gt;
我们会增加一个特征，是另外一个特征的非线性变换，我们进一步降低MAE，最后得到一个满意的回归&lt;/p&gt;
">3.2 特征创建</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/33-wei-shu-yue-jian/"" data-c="
          &lt;p style=&#34;text-align: left;&#34;&gt;当数据集中包含大量特征时：
- 有些特征包含丰富的预测信息；
- 有些特征之间具有一定的相关性；
- 有些特征只包含噪声或不相关信息；
只保留有意义的特征不仅可以使数据集易于管理，而且可以使预测结果不受数据中噪声的影响，预测精度更好。&lt;/p&gt;
&lt;strong&gt;维数约减&lt;/strong&gt;
消除输入数据集的某些特征，创建一个有限特征的数据集（包含所有需要的信息），以更有效的方式预测目标变量。
注：多数维数约简算法的一个主要假设：
数据包含加性高斯白噪声。
维数约简可以减少噪声的集合跨度，以此减少噪声的能量。
&lt;hr /&gt;
&lt;p&gt;常用的维数约简方法：&lt;/p&gt;
&lt;pre&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; font-family: arial,&#39;宋体&#39;,sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: 24px; orphans: 2; overflow-wrap: break-word; text-align: left; text-decoration: none; text-indent: 2em; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px; zoom: 1;&#34;&gt;数据维数约简的方法可以分为线性维数约简和非线性维数约简，而非线性维数约简又分为基于核函数的方法和基于特征值的方法。线性维数约简的方法主要有&lt;/span&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;主成分分析&lt;/a&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; font-family: arial,&#39;宋体&#39;,sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: 24px; orphans: 2; overflow-wrap: break-word; text-align: left; text-decoration: none; text-indent: 2em; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px; zoom: 1;&#34;&gt;（PCA）、&lt;/span&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;独立成分分析&lt;/a&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; font-family: arial,&#39;宋体&#39;,sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: 24px; orphans: 2; overflow-wrap: break-word; text-align: left; text-decoration: none; text-indent: 2em; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px; zoom: 1;&#34;&gt;（ICA）、线性判别分析（LDA）、局部特征分析（LFA）等等。基于核函数的非线性维数约简方法有基于核函数的主成分分（KPCA）、基于核函数的独立成分分析（KICA）、基于核函数的决策分析（KDA）等等。基于特征值的非线性降维方法有ISOMAP 和LLE。&lt;/span&gt;&lt;/pre&gt;
&lt;div class=&#34;para&#34;&gt;&lt;a href=&#34;https://baike.baidu.com/item/PCA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PCA&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;&lt;a href=&#34;https://baike.baidu.com/item/LCA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LCA&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;LDA\ Fisher DA&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;&lt;a href=&#34;https://baike.baidu.com/item/LFA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LFA&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;KPCA&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;KICA&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;&lt;a href=&#34;https://baike.baidu.com/item/KDA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KDA&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;ISOMAP&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;LLE&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;&lt;a href=&#34;https://baike.baidu.com/item/SVM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SVM&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;智能算法&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;数学变换(DFT DCT)&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;KLT&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;&lt;a href=&#34;https://baike.baidu.com/item/SVD/17186639&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34; data-lemmaid=&#34;17186639&#34;&gt;SVD&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;P-NORMS 和&lt;a href=&#34;https://baike.baidu.com/item/%E5%86%85%E7%A7%AF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;内积&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;&lt;a href=&#34;https://baike.baidu.com/item/MLT&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MLT&lt;/a&gt;(多核学习)&lt;/div&gt;
&lt;div class=&#34;para&#34;&gt;流形学习&lt;/div&gt;
&lt;div&gt;T-SNE&lt;/div&gt;
&lt;hr /&gt;
&lt;h5&gt;&lt;strong&gt;降维分类：&lt;/strong&gt;&lt;/h5&gt;
按照不同的标准，降维算法可分为不同种类。例如:
1.根据所作的映射F是否线性，降维算法相应地分为线性算法和非线性算法。主成分分析(PCA)、线性判别分别(LDA)、自组织特征映射(Self-organizing maps，SOM) [57-61]、主曲线(Principal Curves) [69,70]等为经典的线性算法；等距映射(Isometric Feature Mapping，ISOMAP) [74]、局部线性嵌入(Locally Linear Embedding，LLE)
[71]和拉普拉斯特征值映射(Laplacian Eigenmaps，LE) [34]等均为典型的非线性降维算法；
2.根据是否将数据集的局部几何结构纳入考虑，降维算法又可分为局部降维算法与非局部降维算法。如PCA和LDA等是典型性的全局型降维算法；而诸如LLE和LE一些流形学习算法以及其对应的线性化算法，局部保持投影(Locality Preserving Projections，LPP) [76]和近邻保持嵌入(Neighborhood Preserving Embedding，NPE) [77]均为局部型降维算法；
3.根据降维过程是否利用监督信息或其它形式的标号，降维算法可分为监督型算法和无监督型算法。如PCA、LPP和LLE等为无监督型约简算法；而LDA和最大间隔准则(MaximumMargin Criterion，MMC)等为有监督型约简算法；
4.根据所作的映射F是否依赖于样本数据集，可分为数据依赖型约简算法与数据独立型约简算法。到目前为止，众多降维算法中使用的映射F均需从数据集X中学习获得，如PCA的投影方向与数据集的分布有关；而另外新出现的降维算法，如随机投影RP等，所做的映射与数据集的性质并无本质联系，所以称其为数据独立型降维方法
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;协方差矩阵&lt;/strong&gt;&lt;br&gt;
协方差是对两个随机变量联合分布线性相关程度的一种度量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个随机变量越线性相关，协方差越大；&lt;/li&gt;
&lt;li&gt;线性无关，协方差为零。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;相关系数&lt;/strong&gt;(Correlation coefficient) 是按积差方法计算，同样以两变量与各自平均值的离差为基础，通过两个离差相乘来反映两变量之间相关程度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相关系数取值在-1到1之间；&lt;/li&gt;
&lt;li&gt;相关系数为0时，称两个变量不相关;&lt;/li&gt;
&lt;li&gt;相关系数为1时，称两个变量完全相关，即具有线性关系;&lt;/li&gt;
&lt;li&gt;越接近于0说明两个变量的相似度越小；&lt;/li&gt;
&lt;li&gt;越接近于1说明两个变量的相似度越大。&lt;br&gt;
一般地，相关系数 &amp;gt; 0.8称为高度相关，相关系数 &amp;lt; 0.3称为低度相关，其它称为中度相关。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;cov()：&lt;/strong&gt;协方差矩阵每个元素是各个向量元素之间的协方差。&lt;br&gt;
&lt;strong&gt;corrcoef()：&lt;/strong&gt;相关系数矩阵每个元素是各个向量元素之间的相关系数&lt;br&gt;
相关系数矩阵是对称矩阵&lt;br&gt;
相关系数矩阵中输入数据每行是一个变量（特征），每列是一个样本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;heatmap()&lt;/strong&gt; 热力图&lt;br&gt;
&lt;code&gt;import seaborn as sns&lt;br&gt;
import matplotlib.pyplot as plt&lt;/p&gt;
&lt;h1 id=&#34;heatmap函数是画热力图的&#34;&gt;heatmap函数是画热力图的&lt;/h1&gt;
&lt;p&gt;sns.heatmap(cov_data)&lt;/code&gt;&lt;br&gt;
加上&lt;code&gt;sns.heatmap(cov_data,annot=True)&lt;/code&gt;可以显示标志的缩写&lt;br&gt;
参数annot(annotate的缩写)默认取值False；如果是True，在热力图每个方格写入矩阵对应位置数据。&lt;br&gt;
&lt;code&gt;sns.heatmap(cov_data,annot =True,cmap=&#39;rainbow&#39;)&lt;/code&gt;绘制成彩色的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;发现：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主对角线元素为1，因为变量自相关系数为1；&lt;/li&gt;
&lt;li&gt;第1和第3、第1和第4、第3和第4特征之间具有高度相关性；&lt;/li&gt;
&lt;li&gt;第2特征与其他特征相关度较低。&lt;br&gt;
相关特征可能包含相似属性，因而可以约减高度相关特征。&lt;br&gt;
维数约减算法有很多，如PCA、LFA、LDA、LSA、ICA、T-SNE等。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p style=&#34;text-align: left;&#34;&gt;PCA主成分分析
主成分分析 (Principal Component Analysis, PCA)，又称主元分析、主分量分析，旨在利用降维的思想简化数据。
PCA的主要思想是通过对原始变量相关矩阵内部结构的关系研究，找出影响效果某一要素的几个综合指标，使综合指标为原来变量的线性拟合。
&lt;span style=&#34;color: #0000ff;&#34;&gt;将m维特征映射到p维上，这p维是新的正交特征，被称为主成分。&lt;/span&gt;
p维特征是在原有m维特征的基础上重新构造出来的，&lt;span style=&#34;color: #0000ff;&#34;&gt;不仅保留了原始变量的主要信息，且彼此间不相关，又比原始变量具有某些更优越的性质。&lt;/span&gt;&lt;/p&gt;
PCA算法步骤：&lt;img class=&#34;alignnone wp-image-127 size-full&#34; src=&#34;https://mingking.vip/wp-content/uploads/2020/05/1-e1590922420984.png&#34; alt=&#34;&#34; width=&#34;671&#34; height=&#34;417&#34; /&gt;
可以采用&lt;strong&gt;中心化、标准化、归一化、白化&lt;/strong&gt;等数据预处理方法。也就是对数据的线性修正和非线性修正的方法处理原始数据
&lt;p&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;PCA(n_components=None, copy=True, whiten=False, svd_solver=‘full’)&lt;/span&gt;&lt;br&gt;
&lt;strong&gt;参数：n_components&lt;/strong&gt;：所要保留的主成分个数n，缺省时默认为None。&lt;br&gt;
赋值为int，如&lt;strong&gt;n_components=1&lt;/strong&gt;，将把原始数据降到一个维度；&lt;br&gt;
赋值为string，如&lt;strong&gt;n_components=&#39;mle&#39;&lt;/strong&gt;，将自动选取特征个数n，使得满足所要求的方差百分比。&lt;br&gt;
&lt;strong&gt;copy&lt;/strong&gt;：表示是否在运行时将原始训练数据复制一份,缺省时默认为True。&lt;br&gt;
若为True，则在原始数据的副本上进行运算，原始数据不改变；&lt;br&gt;
若为False，则运行PCA算法后，原始训练数据的值改变。&lt;br&gt;
&lt;strong&gt;whiten&lt;/strong&gt;：白化，使得每个特征具有相同的方差，缺省时默认为False。&lt;br&gt;
&lt;strong&gt;svd_solver&lt;/strong&gt;：指定奇异值分解SVD的方法，缺省时默认auto。&lt;br&gt;
有4个可选择的值：{‘auto’, ‘full’, ‘arpack’, ‘randomized’，}&lt;br&gt;
&lt;strong&gt;返回值&lt;/strong&gt;：&lt;strong&gt;n_components_&lt;/strong&gt;：返回所保留的成分个数n；&lt;br&gt;
&lt;strong&gt;components_&lt;/strong&gt;：返回具有最大方差的成分；&lt;br&gt;
&lt;strong&gt;explained_variance_ratio_&lt;/strong&gt;：返回保留的n个成分各自的方差百分比。&lt;/p&gt;
&lt;div&gt;&lt;strong&gt;特征分解是奇异值分解的一个特例&lt;/strong&gt;，一般PCA库都是基于SVD实现。
&lt;strong&gt;svd_solver 参数&lt;/strong&gt;：
指定奇异值分解SVD的方法：‘auto’, ‘full’, ‘arpack’, ‘randomized’
&lt;strong&gt;‘full’&lt;/strong&gt;：传统意义上的SVD，使用scipy库对应的SVD实现
&lt;strong&gt;‘randomized’&lt;/strong&gt;和&lt;strong&gt;‘arpack’&lt;/strong&gt; ：一般适用于数据量大，数据维度多同时主成分数比例又较低的PCA降维，使用了加快SVD的随机算法。
&lt;strong&gt; 区别&lt;/strong&gt;： randomized使用scikit-learn的SVD实现；
arpack使用scipy库的sparse SVD实现
&lt;strong&gt;‘auto’&lt;/strong&gt;：PCA算法自行在前面三种算法里权衡，选择一个合适的SVD算法来降维。
一般来说，使用默认值就够了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;">3.3 维数约简</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/zuo-ye-3/"" data-c="
          &lt;p&gt;♦  从Python3.5开始，Python引入了新的矩阵乘法运算符“@”，*运算符不再用于矩阵相乘，专门用于按位操作，参与计算的两个矩阵（向量）维数相同，两个矩阵相同位置的对应元素进行操作；矩阵加法必须要求两个矩阵行列数一致。&lt;/p&gt;
&lt;p&gt;♦&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;  &lt;a href=&#34;http://www.cainiaoxueyuan.com/bc/5893.html&#34;&gt;numpy.matlib&lt;/a&gt;矩阵生成函数&lt;/span&gt;&lt;br&gt;
numpy.matlib.empty()函数返回一个新的矩阵，而不初始化元素&lt;br&gt;
numpy.matlib.eye()函数返回一个矩阵，对角线元素为 1，其他位置为零numpy&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;matlib&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;eye&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt; M&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt; dtype&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;br&gt;
numpy.matlib.ones()函数创建一个以1填充的矩阵&lt;br&gt;
numpy.matlib.rand()函数返回一个给定大小、数据随机填充的矩阵&lt;/p&gt;
&lt;p&gt;♦  numpy.dot()函数计算两个数组的点积，即元素对应相乘&lt;br&gt;
对于二维数组，numpy.dot()计算两个数组的矩阵乘积&lt;br&gt;
numpy.vdot()计算两个向量的点积&lt;br&gt;
numpy.vdot()计算两个矩阵对应元素乘积之和&lt;/p&gt;
&lt;p&gt;♦  关于&lt;a href=&#34;https://www.cnblogs.com/xieshengsen/p/6836430.html&#34;&gt;numpy.linalg&lt;/a&gt;的矩阵运算函数&lt;br&gt;
trace函数计算对角线元素的和&lt;br&gt;
solve函数可用来求解线性方程组&lt;br&gt;
inv函数计算方阵的逆矩阵，必须是方阵。&lt;br&gt;
det函数计算矩阵行列式&lt;/p&gt;
&lt;p&gt;♦  下列语句在Python中是合法的&lt;br&gt;
x = y = z = 1&lt;br&gt;
x, y = y, x&lt;br&gt;
x += y&lt;/p&gt;
&lt;p&gt;♦  Python内存管理&lt;br&gt;
变量不必事先声明&lt;br&gt;
变量可以不指定类型，会自动根据赋值语句来决定类型 ，使用前必须赋值，在赋值的同时变量也就创建了&lt;br&gt;
变量无须指定类型&lt;br&gt;
可以使用del释放资源&lt;/p&gt;
&lt;p&gt;♦ Python合法的标识符：以字母，下划线开头；全部则是由字母，数字，下划线组成。&lt;/p&gt;
&lt;p&gt;♦ 值为0的任何数字对象的布尔值是False&lt;br&gt;
空字符串的布尔值是False&lt;br&gt;
字典也可以用于布尔测试&lt;br&gt;
空列表对象的布尔值是False&lt;/p&gt;
&lt;p&gt;♦ &lt;a href=&#34;https://www.cnblogs.com/hey-jacky/p/9544490.html&#34;&gt;  复数&lt;/a&gt;&lt;br&gt;
实部和虚部都是浮点数&lt;br&gt;
方法conjugate返回复数的共轭复数&lt;br&gt;
表示复数的语法是real + image j&lt;br&gt;
虚部必须后缀j，可为大写也可为小写&lt;/p&gt;
&lt;p&gt;♦ python不支持char类型&lt;/p&gt;
&lt;p&gt;♦ 字符串&lt;br&gt;
字符应该视为长度为1的字符串&lt;br&gt;
既可以用单引号，也可以用双引号创建字符串&lt;br&gt;
在三引号字符串中可以包含换行回车等特殊字符&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/itdyb/p/5037167.html&#34;&gt;python字符串&lt;/a&gt;不是通过NUL或者&#39;\0&#39;来结束的&lt;/p&gt;
&lt;p&gt;♦ 以下是&lt;a href=&#34;https://blog.csdn.net/W_weiying/article/details/83058855?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&#34;&gt;创建一个字典&lt;/a&gt;的语句。&lt;br&gt;
dict2 = { 3 : 5 }&lt;br&gt;
dict1 = { }&lt;br&gt;
dict4 = {(1,2,3): “uestc”}&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦ &lt;/span&gt;分类等级经过虚拟编码后的输出结果的数据结构是&lt;strong&gt;数据框&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;♦  文件的地址存储于对象的.filenames属性内，内容存储于对象的&lt;strong&gt;.data&lt;/strong&gt;属性内，标签存储于对象的&lt;strong&gt;&lt;i class=&#34;fb red fl&#34;&gt; &lt;/i&gt;.target&lt;/strong&gt;属性内。&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦&lt;/span&gt; 文本text_1 = &#39;we love data science&#39;，文本text_2 = &#39;data science is wonderful&#39;，组合文档documents = [text_1, text_2]，则documents=&lt;strong&gt;[&#39;we love data science&#39;, &#39;data science is wonderful&#39;]&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦&lt;/span&gt; 数组进行算术运算是逐个元素&lt;strong&gt;按位&lt;/strong&gt;操作&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;♦  Numpy处理不同形状数组之间算术运算的特有方式是&lt;strong&gt;按位操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;♦ 经过CountVectorizer特征提取后得到的文本矩阵的行数表示样本数，列数表示特征数。&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;♦  Python中列表可以按顺序存储异质对象。&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;♦  Python中字典允许访问复杂内容、多维数据的数据结构。&lt;/p&gt;
&lt;p&gt;♦  ndarray对象初始化之后，数组的大小固定，导致数据更改不方便，插入或删除数据时需要重新创建一个数组。&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;♦  查看数组，数据结构中的数据转换成其他形式&lt;span style=&#34;font-family: 黑体;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;♦  numpy位置索引比pandas索引速度快。&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;♦  Pandas所有的数据框实际上都是由一维的Numpy数组组成。&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;♦  .reshape方法是对原始数组的动态镜像，得到的结果是原始数组的一个视图。&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #202020; font-family: &#39;Microsoft YaHei&#39;,&#39;SF Pro Display&#39;,Roboto,Noto,Arial,&#39;PingFang SC&#39;,sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦  列表和元组之间的区别&lt;/span&gt;&lt;br&gt;
相同点：元组与列表都是容器对象，可以存储不同类型的内容，且元组的访问与遍历方式与列表相同。&lt;br&gt;
不同点：1 声明方式不同，元组的声明使用小括号tuple()，而列表使用方括号list[]，当声明只有一个元素的元组时，需要在这个元素的后面添加英文逗号；&lt;br&gt;
2 元组声明和赋值后，不能像列表一样添加、删除和修改元素，即list中有 append()，insert() 函数，tuple中没有，这也说明列表是可变的，而元组是不可变的。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;1、元组声明与赋值&lt;br&gt;
声明一个元组并赋值的语法与列表相同，不同之处是元组使用小括号，列表使用方括号，元素之间也是用英文逗号分隔。需要注意的是，当元组只有一个元素时，需要在元素的后面加一个英文逗号分隔符，以防止与表达式中的小括号混淆。这是因为小括号既可以表示元组，又可以表示表达式中的优先级算符，这就容易产生歧义。&lt;br&gt;
2、 如何更新元组&lt;br&gt;
元组是不可修改类型，虽然在程序运行过程中无法对元组的元素进行插入和删除运算。但元组可以通过再构造一个新的元组替换旧的元组，来实现元素的插入和删除。&lt;br&gt;
3、 元组的访问&lt;br&gt;
元组的访问和列表相同，可以直接使用下标索引访问元组中的单个数据项，也可以使用截取运算符访问子元组。访问运算符包括“[]”和“[:]”运算符，用于访问元组中的单个数据项，或者一个子元组。&lt;br&gt;
4、 元组的遍历&lt;br&gt;
元组的遍历方式和列表相同，都是应用for循环语句遍历元组的元素。&lt;br&gt;
5、 操作元组的常用方法&lt;br&gt;
和列表一样，适用于列表的方法也同样适用于元组的操作。但由于元组的不可修改特性，用于列表的排序、替换、添加等方法，在元组中不能使用。可以使用的主要方法有计算元组个数、求元组中最大值、求元组中最小值等方法。&lt;br&gt;
6、 元组的不可修改特性&lt;br&gt;
元组的不可修改特性可能会让元组变得非常不灵活，因为元组作为容器对象，很多时候需要对容器的元素进行修改，这在元组中是不允许的。元组可以说是列表数据的一种补充，数据的不可修改性在程序设计中也是非常重要的。例如，当需要将数据作为参数传递给API，但不希望API修改参数时，就可以传递一个元组类型；再如，当需要定义一组Key时，也可以采用元组类型。因此可以说元组和列表是互为补充的数据类型。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;">作业3</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/34-yi-chang-jian-ce-yu-chu-li/"" data-c="
          &lt;p&gt;数据点成为异常值主要有三种原因：&lt;br&gt;
♦ &lt;b&gt;数据&lt;/b&gt;&lt;b&gt;点表示极少发生的事件&lt;/b&gt;，但它仍然是一个可能的数据，因为数据分布提供的数据只是一个样本。这时，所有点的产生过程都是相同的，但是异常点由于它的稀缺性而不符合某种推断。在这种情况下，常用的方法是将&lt;b&gt;去除&lt;/b&gt;&lt;b&gt;这样&lt;/b&gt;&lt;b&gt;的&lt;/b&gt;&lt;b&gt;点或&lt;/b&gt;&lt;b&gt;降低权重&lt;/b&gt;，另一种解决方法是&lt;b&gt;增加样本数量&lt;/b&gt;。&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦ &lt;/span&gt; &lt;b&gt;数据点表示经常发生的另一种分布。&lt;/b&gt;当类似情况出现时，可认为是发生了影响样本生成的错误。&lt;b&gt;这样&lt;/b&gt;&lt;b&gt;的异常值必须去除&lt;/b&gt;。&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦ &lt;/span&gt;&lt;b&gt;数据点明显是某种类型的错误。&lt;/b&gt;由于某些原因，会出现数据输入误差，或数据合并产生了问题从而改变了数据的原始值，或者因为数据的完整性问题导致数据被不一致的数值替换。这种情况，最好的应对方法是&lt;b&gt;去除数据，并把它当作随机缺失值&lt;/b&gt;。根据处理的是回归或是分类问题的不同，常用均值或最常见的类来替换异常点。如果不便或不能这样处理，那么建议直接删除这个数据。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如何定位单个数据点异常？&lt;br&gt;
→ 结合EDA分析和箱形图等可视化方式实现&lt;br&gt;
→ 极端值可以当作异常值&lt;br&gt;
什么是极端值？&lt;br&gt;
Ø使用Z-scores时，得分绝对值高于3的观测值为可疑异常值&lt;br&gt;
Ø如果观测量是数据描述，以下两种数据当作可疑异常值，&lt;br&gt;
•第一种是比25分位值减去IQR&lt;em&gt;1.5小的观测量&lt;br&gt;
•第二种是比75分位值加上IQR&lt;/em&gt;1.5大的观测量&lt;br&gt;
注：IQR(Inter quartile range)是四分位距，即75分位值与25分位值的差。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如何使用Z-scores检测异常值？&lt;br&gt;
Ø使用sklearn中StandardScaler函数对所有连续变量进行标准化&lt;br&gt;
Ø找到那些绝对值大于3倍标准差的值。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;单变量方法可以检测出相当多潜在异常值，但是，它不能检测那些不是极端值的异常值。&lt;br&gt;
如果变量本身不是极端值，而它与其它变量或多个变量组合后出现不正常值，如何检测？&lt;br&gt;
——可以先使用维数约简算法，再检查绝对值超过三倍标准偏差的成分。&lt;br&gt;
Scikit-learn库提供了可直接使用并自动标出所有可疑实例的类：&lt;br&gt;
covariance.EllipticEnvelope类：适合鲁棒的数据分布估计，由于异常值是数据总体分布中的极值点，它能够指出数据中的异常值。&lt;br&gt;
svm.OneClassSVM类：可以模拟数据的形状，找出任何新的实例是否属于原来的类（默认情况下假定数据中没有异常值）。修改其参数后能作用于有异常值的数据集，比EllipticEnvelope系统更强大、更可靠。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;EllipticEnvelope&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设全部数据可以表示成基本的多元高斯分布，EllipticEnvelope函数试图找出数据总体分布关键参数。尽可能简化算法背后的复杂估计，可认为该算法主要是&lt;b&gt;检查&lt;/b&gt;&lt;b&gt;每个观测量与总均值的距离&lt;/b&gt;。&lt;br&gt;
由于总均值要考虑数据集中所有变量，该算法能够同时发现单变量和多变量的异常值。&lt;br&gt;
Covariance.EllipticEnvelope函数使用时需要考虑污染参数(contamination parameter) ，该参数是&lt;b&gt;异常值在数据集中的&lt;/b&gt;&lt;b&gt;比例&lt;/b&gt;，默认取值为0.1，最高取值为0.5。&lt;br&gt;
注：鉴于标准正态分布中观测值落在距离均值大于3（Z-score距离）区域的百分比是0.01-0.02，作为初始值，建议污染参数取值为0.01-0.02。&lt;/p&gt;
&lt;p style=&#34;text-align: left;&#34;&gt;EllipticEnvelope函数适用于有控制参数的高斯分布假设，使用时要注意：非标化的数据、二值或分类数据与连续数据混合使用可能引发错误和估计不准确。
EllipticEnvelope函数假设全部数据可以表示成基本的多元高斯分布，当数据中有多个分布时，算法试图将数据适应一个总体分布，倾向于寻找最偏远聚类中的潜在异常值，而忽略了数据中其他可能受异常值影响的区域。&lt;/p&gt;
&lt;p style=&#34;text-align: right;&#34;&gt;&lt;b&gt;——EllipticEnvelope&lt;/b&gt;&lt;b&gt;算法的&lt;/b&gt;&lt;b&gt;局限性&lt;/b&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;OneClassSVM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OneClassSVM是一种机器学习方法：&lt;br&gt;
•  通过学习知道数据应该服从什么分布&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•  &lt;/span&gt;适用于具有更多变量的数据集&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•  &lt;/span&gt;检查新的样本是否符合以前的数据分布&lt;br&gt;
参数有kernel、degree、gamma和nu：&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;• &lt;/span&gt; Kernel和Degree：这两个参数是相关的，通常建议取默认值kernel为rbf，degree为3。&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;• &lt;/span&gt; Gamma：与rbf核相关的参数，建议设置越低越好。&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;• &lt;/span&gt; Nu： 决定模型是否必须符合一个精确的分布，&lt;br&gt;
如果有异常值存在，Nu是必选参数。如果异常值比例很小，则Nu也会很小，反之很大。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
">3.4 异常检测与处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/zuo-ye-4/"" data-c="
          &lt;p&gt;♦ &lt;strong&gt;nunique()&lt;/strong&gt;&lt;br&gt;
nunique()可直接统计dataframe中每列的不同值的个数。&lt;br&gt;
nunique()可直接统计series中不同值的个数，但不能用于list。&lt;br&gt;
unique()统计list中的不同值时，返回的是array.它有三个参数，可分别统计不同的量，返回的都是array.当list中的元素也是list时，尽量不要用这种方法.。&lt;br&gt;
nunique()可直接统计dataframe中每列的不同值的个数,也可用于series,但不能用于list.返回的是不同值的个数.&lt;br&gt;
is_unique()有重复输出FALSE，无重复输出TRUE。&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦ &lt;/span&gt;pandas查看数据结构（行数、列数）的函数是：shape；.shape；shape()；.shape()；shape( )；.shape( )；shape[0]和shape[1]；.shape[0]和.shape[1]；shape[0]、shape[1]；.shape[0]、.shape[1]；&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦ &lt;/span&gt;Pandas库的数据结构有Series 和DataFrame&lt;/p&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦ &lt;/span&gt;pandas查询数据A（DataFrame）全部列名称的代码是 A.columns&lt;br&gt;
pandas查询数据A（DataFrame）全部行名称的代码是 A.index&lt;br&gt;
pandas查询数据A（DataFram）描述性统计的代码是 A.describe()&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦ &lt;/span&gt;loc[]函数用行列标签选择数据, 前闭后闭
iloc[]函数用行列数选择数据, 前闭后开。
iloc[]函数只能访问整型，不能访问布尔数据类型
&lt;/div&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;♦ &lt;/span&gt;将index设置为升序使用函数sort_index()，默认升序，降序即ascending=False
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/xu200yang/article/details/70239109&#34;&gt;python sort、sort_index&lt;/a&gt;方法（排序）&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;">作业4</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/zuo-ye-2/"" data-c="
          &lt;p&gt;对于数据集dataset以文本形式输出为&lt;img src=&#34;https://p.ananas.chaoxing.com/star3/origin/7210d84e067be607ee479483bc18e573.png&#34;  width=&#34;30px&#34;/&gt;，若要输出数值40的，代码正确的是（）。&lt;/p&gt;
&lt;p&gt;这个就是个数据选择的问题,可以使用的方法有：&lt;br&gt;
dataset[&#39;val2&#39;,103]，dataset.loc[103,&#39;val2&#39;]，dataset.ix[103 ,&#39;val2&#39;]，dataset.ix[103,1]，dataset.iloc[3,1]&lt;/p&gt;
&lt;div class=&#34;Zy_TItle clearfix&#34;&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;2.以下输出结果为“True”的是（D）。&lt;br&gt;
A.0.4-0.3 == 0.1&lt;br&gt;
B.0 or 5 &amp;lt; 4&lt;br&gt;
C.3 or 2 &amp;gt; 1&lt;br&gt;
D.2 &amp;gt; 1 or 6&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;解析：一, 在不加括号时候,&lt;strong&gt; and优先级大于or&lt;/strong&gt;
二, x or y 的值&lt;strong&gt;只可能是x或y&lt;/strong&gt;. x为真就是x, x为假就是y
三, x and y 的值&lt;strong&gt;只可能是x或y&lt;/strong&gt;. x为真就是y, x为假就是x&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;Zy_TItle clearfix&#34;&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;对于3 or 2 &amp;gt; 1，2 &amp;gt; 1 为true，3为真，所以答案应该是3&lt;br&gt;
对于2 &amp;gt; 1 or 6  ，2 &amp;gt; 1为真，所以答案为true&lt;/p&gt;
&lt;p&gt;3.Pandas库的数据结构有Series 和DataFrame&lt;/p&gt;
&lt;p&gt;4.round(2.1135,3)的输出结果是    2.114  ；round(1.1135,3)的输出结果是    1.113&lt;br&gt;
解析：round函数一般是四舍五入，但是碰到.5的情况会出现，若取舍位数前的小数是奇数则向下舍，是偶数则向上取；但是又受限于计算机的精度，因而在取舍的时候尽量避免使用round函数。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
5.axis=0表示平均值计算是跨行进行的，获得是列方向的均值，相反axis=1表示跨列计算">作业2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/zuo-ye-5/"" data-c="
          &lt;p&gt;import pandas&lt;br&gt;
help(pandas.DataFrame.describe)查询生成描述性统计数据的函数帮助&lt;br&gt;
DataFrame.describe(percentiles=None, include=None, exclude=None)&lt;br&gt;
其物理意义在于观察这一系列数据的范围。大小、波动趋势等等，便于判断后续对数据采取哪类模型更合适。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;观测值的数量：shape[0]&lt;br&gt;
标准差：std()&lt;br&gt;
1/4分位数：quantile(0.25)&lt;br&gt;
中位数：median()&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_39577827/article/details/104220730&#34;&gt;python可视化（十种常用图）&lt;/a&gt;&lt;br&gt;
boxplot()绘制箱线图&lt;br&gt;
Scatter绘制散点图&lt;br&gt;
hist绘制直方图&lt;br&gt;
plot绘制折线图&lt;br&gt;
bar绘制条形图&lt;br&gt;
pie绘制饼图&lt;br&gt;
heatmap绘制热力图&lt;br&gt;
figure绘制蜘蛛网图&lt;br&gt;
jointplot绘制二元变量分布图&lt;br&gt;
pairplot绘制成对关系&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/32482328&#34;&gt;Z-scores标准化&lt;/a&gt;&lt;br&gt;
将特征映射为均值为0、标准差为1的新特征&lt;br&gt;
将原始数据转换为无量纲化值&lt;br&gt;
使各指标值都处于同一数量级别&lt;br&gt;
Z-scores 标准化属于线性变换&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;鲁棒缩放&lt;br&gt;
采用中位数和IQR对每个特征进行单独缩放&lt;br&gt;
IQR：第一个和第三个四分位数&lt;br&gt;
鲁棒缩放对于异常值更鲁棒&lt;br&gt;
鲁棒缩放属于线性变换&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;协方差&lt;br&gt;
两个随机变量越线性相关，协方差越大&lt;br&gt;
线性无关，协方差为零&lt;br&gt;
协方差度量的是线性相关程度&lt;br&gt;
协方差只表示线性相关的方向，取值正无穷到负无穷。&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/liao392781/article/details/96423475&#34;&gt;方差、标准差、协方差三者的定义和计算&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;相关系数&lt;br&gt;
相关系数取值在-1到1之间&lt;br&gt;
变量不相关，相关系数为0&lt;br&gt;
越接近于0说明两个变量的相似度越小&lt;br&gt;
越接近于1说明两个变量的相似度越大&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;数据分析的主要步骤有：&lt;br&gt;
检查数据&lt;br&gt;
使用描述统计量和图表对数据进行描述&lt;br&gt;
考察变量之间的关系&lt;br&gt;
检验特征分布&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;处理缺失值、异常值和重复值问题&lt;br&gt;
各列分别有多少缺失值data.apply(lambda x: sum(x.isnull()),axis=0)&lt;br&gt;
总共有多少行有缺失值len(data.apply(lambda x: sum(x.isnull()),axis=1).nonzero()[0])&lt;br&gt;
各行分别有多少缺失值data.apply(lambda x: sum(x.isnull()),axis=1)&lt;br&gt;
删除重复值data.drop_duplicates()&lt;/p&gt;
&lt;hr /&gt;
&lt;div class=&#34;clearfix&#34;&gt;
&lt;div&gt;
&lt;p&gt;数据预处理的方法&lt;br&gt;
• 白化&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 归一化&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 中心化&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 标准化&lt;/p&gt;
&lt;hr /&gt;
&lt;div class=&#34;clearfix&#34;&gt;EDA指的是数据科学中的
探索性数据分析；
探索性数据分析(Exploratory Data Analysis)；
探索性数据分析Exploratory Data Analysis；
Exploratory Data Analysis；
&lt;hr /&gt;
&lt;/div&gt;
Python中，生成描述性统计数据的函数是 describe()
Python中，特征去重复统计的函数是 unique()
Python中生成共生矩阵/交叉表的函数是 crosstab()
计算协方差矩阵的函数是cov()
&lt;/div&gt;
&lt;/div&gt;">作业5</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/zheng-ze-biao-da-shi/"" data-c="
          &lt;div id=&#34;article_content&#34; class=&#34;article_content clearfix&#34;&gt;
&lt;div id=&#34;content_views&#34; class=&#34;htmledit_views&#34;&gt;
&lt;h3&gt;正则表达式&lt;/h3&gt;
正则表达式是用来匹配与查找字符串的，从网上爬取数据自然或多或少会用到正则表达式。
Python 的正则表达式要先引入 re 模块，正则表达式以 r 引导，例如：
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;\d+&#34;
m=re.search(reg,&#34;abc123cd&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
其中 r&#34;\d+&#34;正则表达式表示匹配连续的多个数值，search 是 re 中的函数，从&#34;abc123cd&#34; 字符串中搜索连续的数值，得到&#34;123&#34;，返回一个匹配对象，因此程序的结果如下： 从结果看出，在指定的字符串中找到了连续的数值，它们是&#34;123&#34;，span(3,6)表示开始 位置是 3，结束位置是 6，这正好是&#34;123&#34;在&#34;abc123cd&#34;中的位置。
&lt;p&gt;Python 中关于正则表达式的规则比较多，下面将介绍主要的内容，详细内容读者可以 参考相关资料。&lt;/p&gt;
&lt;h3&gt;1、字符&#34;\d&#34;匹配 0-9 之间的一个数值。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;\d&#34;
m=re.search(reg,&#34;abc123cd&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果找到了第一个数值&#34;1&#34;:
&lt;h3&gt;2、字符&#34;+&#34;重复前面一个匹配字符一次或者多次。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;b\d+&#34;
m=re.search(reg,&#34;a12b123c&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果找到了&#34;b123&#34;:
&lt;p&gt;注意：r&amp;quot;b\d+&amp;quot;第一个字符要匹配&amp;quot;b&amp;quot;，后面是连续的多个数字，因此是&amp;quot;b123&amp;quot;，不是&amp;quot;a12&amp;quot;。&lt;/p&gt;
&lt;h3&gt;3、字符&#34;*&#34;重复前面一个匹配字符零次或者多次。 &#34;*&#34;与&#34;+&#34;类似，但有区别，例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;ab+&#34;
m=re.search(reg,&#34;acabc&#34;)
print(m)
reg=r&#34;ab*&#34;
m=re.search(reg,&#34;acabc&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果： 由此可见 r&#34;ab+&#34;匹配的是&#34;ab&#34;，但是 r&#34;ab*&#34;匹配的是&#34;a&#34;，因为 r&#34;ab*&#34;表示&#34;b&#34;可以重复 零次，但是&#34;+&#34;却要求&#34;b&#34;重复一次以上。
&lt;h3&gt;4、字符&#34;?&#34;重复前面一个匹配字符零次或者一次。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;ab?&#34;
m=re.search(reg,&#34;abbcabc&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果： 匹配结果是&#34;ab&#34;，其中 b 重复一次。
&lt;h3&gt;5、字符&#34;.&#34;代表任何一个字符，但是没有特别声明时不代表字符&#34;\n&#34;。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
s=&#34;xaxby&#34;
m=re.search(r&#34;a.b&#34;,s)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果&#34;.&#34;代表了字符&#34;x&#34;
&lt;h3&gt;6、&#34;|&#34;代表把左右分成两个部分。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
s=&#34;xaabababy&#34;
m=re.search(r&#34;ab|ba&#34;,s)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果匹配&#34;ab&#34;或者&#34;ba&#34;都可以：
&lt;h3&gt;7、特殊字符使用反斜线&#34;\&#34;引导，例如&#34;\r&#34;、&#34;\n&#34;、&#34;\t&#34;、&#34;\\&#34;分别表示回车、换行、制 表符号与反斜线自己本身。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;a\nb?&#34;
m=re.search(reg,&#34;ca\nbcabc&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果匹配&#34;a\n\b&#34;:
&lt;h3&gt; 8、字符&#34;\b&#34;表示单词结尾，单词结尾包括各种空白字符或者字符串结尾。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;car\b&#34;
m=re.search(reg,&#34;The car is black&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果匹配&#34;car&#34;，因为&#34;car&#34;后面是以个空格：
&lt;h3&gt;9、&#34;[]&#34;中的字符是任选择一个，如果字符是 ASCII 码中连续的一组，那么可以使用&#34;-&#34; 符号连接，例如[0-9]表示 0-9 的其中一个数字，[A-Z]表示 A-Z 的其中一个大写字符，[0-9A-Z] 表示 0-9 的其中一个数字或者是 A-Z 的其中一个大写字符。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;x[0-9]y&#34;
m=re.search(reg,&#34;xyx2y&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果匹配&#34;x2y&#34;:
&lt;h3&gt;10、&#34;^&#34;出现在[]的第一个字符位置，就代表取反，例如[^ab0-9]表示不是 a、b，也不是 0-9 的数字。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;x[^ab0-9]y&#34;
m=re.search(reg,&#34;xayx2yxcy&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果匹配&#34;xcy&#34;:
&lt;h3&gt;11、&#34;\s&#34;匹配任何空白字符，等价&#34;[\r\n\x20\t\f\v]&#34;。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
s=&#34;1a ba\tbxy&#34;
m=re.search(r&#34;a\sb&#34;,s)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果匹配&#34;a b&#34;：
&lt;h3&gt;12、&#34;\w&#34;匹配包括下划线子内的单词字符，等价于&#34;[a-zA-Z0-9_]&#34;。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;\w+&#34;
m=re.search(reg,&#34;Python is easy&#34;)
print(m) &lt;/code&gt;&lt;/pre&gt;
结果匹配&#34;Python&#34;：
&lt;h3&gt;13、&#34;^&#34;匹配字符串的开头位置。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;^ab&#34;
m=re.search(reg,&#34;cabcab&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果： None 没有匹配到任何字符，因为&#34;cabcab&#34;中虽然有&#34;ab&#34;，但不是&#34;ab&#34;开头。
&lt;h3&gt;14、&#34;$&#34;字符匹配字符串的结尾位置。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;ab$&#34;
m=re.search(reg,&#34;abcab&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
匹配结果是最后一个&#34;ab&#34;，而不是第一个&#34;ab&#34;:
&lt;h3&gt;15、使用括号(...)可以把(...)看成一个整体，经常与&#34;+&#34;、&#34;*&#34;、&#34;?&#34;的连续使用，对(...)部 分进行重复。 例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import re
reg=r&#34;(ab)+&#34;
m=re.search(reg,&#34;ababcab&#34;)
print(m)&lt;/code&gt;&lt;/pre&gt;
结果匹配&#34;abab&#34;，&#34;+&#34;对&#34;ab&#34;进行了重复：
&lt;h3&gt;1.8.2 查找匹配字符串&lt;/h3&gt;
正则表达式库 re 的 search 函数使用正则表达式对要匹配的字符串进行匹配，如果匹配 不成功就返回 None，如果匹配成功就返回一个匹配对象。
匹配对象调用 start()函数得到匹 配字符串的开始位置，匹配对象调用 end()函数得到匹配字符串的结束位置。
search 虽然只 返回第一次匹配的结果，但是我们只要连续使用 search 函数就可以找到字符串中全部匹配 的字符串。                  例：
匹配找出英文句子中所有单词 我们可以使用正则表达式 r&#34;[A-Za-z]+\b&#34;匹配单词，它表示匹配由大小写字母组成的连续 多个字符，一般是一个单词，之后&#34;\b&#34;表示单词结尾。
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;import re
s=&#34;I am testing search function&#34;
reg=r&#34;[A-Za-z]+\b&#34;
m=re.search(reg,s)
while m!=None:
start=m.start()
end=m.end()
print(s[start:end])
s=s[end:]
m=re.search(reg,s)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;hr /&gt;
&lt;p&gt;原文：&lt;a href=&#34;https://blog.csdn.net/weixin_43717681/article/details/106266182&#34;&gt;https://blog.csdn.net/weixin_43717681/article/details/106266182&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;">正则表达式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/ju-lei-wen-ti/"" data-c="
          &lt;div id=&#34;article_content&#34; class=&#34;article_content clearfix&#34;&gt;
&lt;div id=&#34;content_views&#34; class=&#34;markdown_views prism-tomorrow-night-eighties&#34;&gt;
&lt;p&gt;聚类问题是无监督学习，算法的思想是“物以类聚，人以群分”。聚类算法感知样本间的相似度，进行类别归纳，对新的输入进行输出预测，输出变量取有限个离散值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;K-means&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
又称K-均值或K-平均聚类算法。算法思想就是首先随机确定K个中心点作为聚类中心，然后把每个数据点分配给最邻近的中心点，分配完成后形成K个聚类，计算各个聚类的平均中心点，将其作为该聚类新的类中心点，然后重复迭代上述步骤直到分配过程不再产生变化&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;K-Means的主要优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li&gt;原理比较简单，实现也容易，收敛速度快&lt;/li&gt;
 	&lt;li&gt;聚类效果较优&lt;/li&gt;
 	&lt;li&gt;算法的可解释度比较强&lt;/li&gt;
 	&lt;li&gt;主要需要调参的参数仅仅是簇数K&lt;/li&gt;
&lt;/ul&gt;
&lt;strong&gt;K-Means的缺点&lt;/strong&gt;
&lt;ul&gt;
 	&lt;li&gt;K值的选取不好把握&lt;/li&gt;
 	&lt;li&gt;不平衡数据集的聚类效果不佳&lt;/li&gt;
 	&lt;li&gt;采用迭代方法，得到的结果只是局部最优&lt;/li&gt;
 	&lt;li&gt;对噪音和异常点比较的敏感&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;高斯混合模型&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
指的是多个高斯分布函数的线性组合，是一种广泛使用的聚类算法，该方法使用了高斯分布作为参数模型&lt;/p&gt;
&lt;ul&gt;
 	&lt;li&gt;单高斯模型：高斯分布，有时又称为正态分布&lt;/li&gt;
 	&lt;li&gt;高斯混合模型：混合模型是一个可以用来表示在总体分布中含有K个子分布的概率模型，换句话说，混合模型表示了观测数据在总体中的概率分布，他是一个由k个子分布组成的混合分布&lt;/li&gt;
 	&lt;li&gt;混合高斯和K-means很相似，相似点在于两者的分类受初始值影响；两者可能限于局部最优解；两者的类别的个数都要靠采择。混合高斯计算复杂度高于k-means&lt;/li&gt;
 	&lt;li&gt;k-means属于硬聚类，要么属于这类，要么属于那类；而GMM属于混合式软聚类，一个样本70%属于A，30%属于B&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;密度聚类：&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
密度聚类算法假设聚类结构能通过样本分布的密度程度确定，算法从样本密度的角度来考察样本之间的可连接性，并给予可连接样本不断扩展聚类簇已获得最终的聚类结构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;层次聚类：&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
层次聚类算法试图在不同层次对数据进行划分，从而形成树形的聚类结构。数据集的划分可采用“自底向上”的聚合策略，也可采用“自顶向下”的分拆策略&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;谱聚类：&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
它是一种基于图论的聚类方法，将带权无向图划分为两个或两个以上的最有子图，使子图内部尽量相似，而子图键距离尽量距离较远，以达到常见的聚类的目的&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
转自：&lt;a href=&#34;https://blog.csdn.net/weixin_43717681/article/details/104205802&#34;&gt;https://blog.csdn.net/weixin_43717681/article/details/104205802 &lt;/a&gt;
&lt;/div&gt;">聚类问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/matplotlib-ku-python-shu-ju-ke-shi-hua/"" data-c="
          &lt;div id=&#34;article_content&#34; class=&#34;article_content clearfix&#34;&gt;
&lt;div id=&#34;content_views&#34; class=&#34;htmledit_views&#34;&gt;
&lt;h1&gt;&lt;a name=&#34;t0&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t0&#34;&gt;&lt;/a&gt;Matplotlib基础&lt;/h1&gt;
&lt;h2&gt;&lt;a name=&#34;t1&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t1&#34;&gt;&lt;/a&gt;Matplotlib库介绍&lt;/h2&gt;
&lt;ol&gt;
 	&lt;li&gt;Matplotlib是Python的绘图库，是和交互式的进行制图，而且可以方便的将它作为绘图软件，嵌入GUI应用程序中&lt;/li&gt;
 	&lt;li&gt;Matplotlib库由各种可视化类构成，内部结构复杂&lt;/li&gt;
 	&lt;li&gt;Matplotlib.pyplot是绘制各类可视化图形的命令字库，相当于快捷方式&lt;/li&gt;
 	&lt;li&gt;Matplotlib文档完备，并且gallery页面中有上百幅缩略图，打开之后有源代码。如果需要绘制某种类型的图，只需要在这个页面上浏览、复制、粘贴一下，大多都能够通过修改数据和设置搞定&lt;/li&gt;
&lt;/ol&gt;
&lt;a href=&#34;https://matplotlib.org/gallery/index.html&#34; rel=&#34;nofollow&#34;&gt;Gallery&lt;/a&gt;
&lt;h2&gt;&lt;a name=&#34;t2&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t2&#34;&gt;&lt;/a&gt;快速绘图&lt;/h2&gt;
&lt;ol&gt;
 	&lt;li&gt;Matplotlib中的快速绘图的函数库可以通过import语句导入&lt;/li&gt;
 	&lt;li&gt;调用figure创建一个绘图对象，并且使它成为当前的绘图对象&lt;/li&gt;
 	&lt;li&gt;通过figure参数可以指定绘图对象的宽度和高度，单位为英寸；dpi参数指定绘图对象的分辨率，即每英寸可以多少个像素，缺省值为80&lt;/li&gt;
 	&lt;li&gt;也可以不创建绘图对象直接调用plot函数直接绘图，Matplotlib会自动创建一个绘图对象&lt;/li&gt;
 	&lt;li&gt;如果需要同时绘制多幅图标的话，可以给figure传递一个整数参数指定图标的序号，如果所指定序号的绘图对象已经存在的话，将不创建新的对象，而只是让它成为当前绘图对象&lt;/li&gt;
 	&lt;li&gt;plot函数的调用方式很灵活，使用关键字参数指定各种属性（label：给所绘制的曲线一个名字，此名字在图示（legend）中显示。color：指定曲线的颜色。linewidth：指定曲线的宽度。参数&#34;b--&#34;:指定曲线的颜色和线型）&lt;/li&gt;
 	&lt;li&gt;plt.xlabel/ylabel:设置X轴/Y轴的文字&lt;/li&gt;
 	&lt;li&gt;plt.title：设置图标的标题&lt;/li&gt;
 	&lt;li&gt;plt.ylim：设置Y轴的范围&lt;/li&gt;
 	&lt;li&gt;plt.legend：图例图示&lt;/li&gt;
 	&lt;li&gt;plt.show():显示出创建的所有绘图对象&lt;/li&gt;
 	&lt;li&gt;plt.savefig()将当前的figure对象保存成图像文件，图像格式由图像文件的扩展名决定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs kotlin&#34;&gt;import numpy as np
import matplotlib.pyplot as plt
&lt;p&gt;x=np.linspace(0,10,100)&lt;br&gt;
y=np.sin(x)&lt;br&gt;
z=np.cos(x**2)&lt;/p&gt;
&lt;p&gt;plt.plot(x,y,&amp;quot;r-&amp;quot;,label=&amp;quot;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sin(x)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&amp;quot;,linewidth=2)&lt;br&gt;
plt.plot(x,y,&amp;quot;b--&amp;quot;,label=&amp;quot;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;cos(x^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&amp;quot;)&lt;/p&gt;
&lt;p&gt;plt.xlabel(&amp;quot;Times(s)&amp;quot;)&lt;br&gt;
plt.ylabel(&amp;quot;Volt&amp;quot;)&lt;br&gt;
plt.title(&amp;quot;PyPlot First Example&amp;quot;)&lt;br&gt;
plt.legend()&lt;/p&gt;
&lt;p&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a name=&#34;t3&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t3&#34;&gt;&lt;/a&gt;折线图&lt;/h1&gt;
折线图：通常用来表示数据随时间或有序类别变化的趋势
&lt;p&gt;&lt;strong&gt;简单折线图&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;import matplotlib.pyplot as plt
data=[1,2,3,4,5,6,7,8,9,1,2,4,5,7,9]
#随意创建的数据
plt.plot(data)
#引用Matplotlib库中的pyplot模块绘图
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
 	&lt;li&gt;plot（）函数的第一个参数表示横坐标数据&lt;/li&gt;
 	&lt;li&gt;第二个表示纵坐标数据&lt;/li&gt;
 	&lt;li&gt;第三个表示颜色、线型和标记样式&lt;/li&gt;
 	&lt;li&gt;颜色常用的值有（r/g/b/c/m/y/k/w）&lt;/li&gt;
 	&lt;li&gt;线型常用的值（-/--/:/-.）&lt;/li&gt;
 	&lt;li&gt;标记样式常用的值有（./,/o/v/^/s/*/D/d/x/&amp;lt;/&amp;gt;/h/H/1/2/3/4/_/|）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
&lt;p&gt;yy=[1,2,3,4,5,3,1,2,7,8]#随便创建的数据&lt;br&gt;
xx=[3,5,4,1,9,3,2,5,6,3]&lt;br&gt;
zz=[2,2,4,7,4,8,2,4,5,6]&lt;br&gt;
plt.plot(yy,color=&#39;r&#39;,linewidth=5,linestyle=&#39;:&#39;,label=&#39;Data 1&#39;)&lt;br&gt;
plt.plot(xx,color=&#39;g&#39;,linewidth=2,linestyle=&#39;--&#39;,label=&#39;Data 2&#39;)&lt;br&gt;
plt.plot(zz,color=&#39;b&#39;,linewidth=0.5,linestyle=&#39;-&#39;,label=&#39;Data 3&#39;)&lt;br&gt;
plt.legend(loc=2)&lt;br&gt;
plt.xlabel(&#39;X轴名称&#39;,fontproperties=&#39;simhei&#39;)&lt;br&gt;
plt.ylabel(&#39;y轴名称&#39;,fontproperties=&#39;simhei&#39;)&lt;br&gt;
plt.title(&#39;折线图美化实例&#39;,fontproperties=&#39;simhei&#39;)&lt;br&gt;
plt.ylim(0,10)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a name=&#34;t4&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t4&#34;&gt;&lt;/a&gt;散点图&lt;/h1&gt;
&lt;ul&gt;
 	&lt;li&gt;在Matplotlib中使用函数Matplotlib.pyplot.scatter绘制散点图&lt;/li&gt;
 	&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qiu931110/article/details/68130199/&#34;&gt;plt.scatter各参数详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a name=&#34;t5&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t5&#34;&gt;&lt;/a&gt;&lt;strong&gt;10个位置随机散点图&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#10个点位置随机散点图
import matplotlib.pyplot as plt
import numpy as np
&lt;p&gt;N=10&lt;br&gt;
x=np.random.rand(N)&lt;br&gt;
y=np.random.rand(N)&lt;br&gt;
plt.scatter(x,y)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t6&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t6&#34;&gt;&lt;/a&gt;10个点随机大小&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#10个点随机大小
import matplotlib.pyplot as plt
import numpy as np
&lt;p&gt;N=10&lt;br&gt;
x=np.random.rand(N)&lt;br&gt;
y=np.random.rand(N)&lt;br&gt;
size=(30*np.random.rand(N))**2&lt;br&gt;
plt.scatter(x,y,s=size)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t7&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t7&#34;&gt;&lt;/a&gt;更改散点颜色、透明度&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#更改散点颜色、透明度：颜色随机，透明度为0.5
import matplotlib.pyplot as plt
import numpy as np
&lt;p&gt;N=10&lt;br&gt;
x=np.random.rand(N)&lt;br&gt;
y=np.random.rand(N)&lt;br&gt;
size=(30*np.random.rand(N))**2&lt;br&gt;
color=np.random.rand(N)&lt;br&gt;
plt.scatter(x,y,s=size,c=color,alpha=0.5)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t8&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t8&#34;&gt;&lt;/a&gt;更改散点形状&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#更改散点形状，点形状改为上三角
import matplotlib.pyplot as plt
import numpy as np
&lt;p&gt;N=10&lt;br&gt;
x=np.random.rand(N)&lt;br&gt;
y=np.random.rand(N)&lt;br&gt;
size=(30*np.random.rand(N))**2&lt;br&gt;
color=np.random.rand(N)&lt;br&gt;
plt.scatter(x,y,s=size,c=color,alpha=0.5,marker=&amp;quot;^&amp;quot;)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t9&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t9&#34;&gt;&lt;/a&gt;一张图绘制两组数据&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#一张图绘制两组数据
import matplotlib.pyplot as plt
import numpy as np
&lt;p&gt;N=10&lt;br&gt;
x1=np.random.rand(N)&lt;br&gt;
y1=np.random.rand(N)&lt;/p&gt;
&lt;p&gt;x2=np.random.rand(N)&lt;br&gt;
y2=np.random.rand(N)&lt;/p&gt;
&lt;p&gt;plt.scatter(x1,y1,alpha=0.5,marker=&amp;quot;^&amp;quot;)&lt;br&gt;
plt.scatter(x2,y2,alpha=0.5,marker=&amp;quot;s&amp;quot;)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t10&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t10&#34;&gt;&lt;/a&gt;为散点图增加图例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#为散点图增加图例
import matplotlib.pyplot as plt
import numpy as np
&lt;p&gt;N=10&lt;br&gt;
x1=np.random.rand(N)&lt;br&gt;
y1=np.random.rand(N)&lt;/p&gt;
&lt;p&gt;x2=np.random.rand(N)&lt;br&gt;
y2=np.random.rand(N)&lt;/p&gt;
&lt;p&gt;plt.scatter(x1,y1,alpha=0.5,marker=&amp;quot;^&amp;quot;,label=&#39;triangle&#39;)&lt;br&gt;
plt.scatter(x2,y2,alpha=0.5,marker=&amp;quot;s&amp;quot;,label=&amp;quot;circle&amp;quot;)&lt;br&gt;
plt.legend(loc=&amp;quot;best&amp;quot;)#自己选择图例在合适的位置&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a name=&#34;t11&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t11&#34;&gt;&lt;/a&gt;柱状图&lt;/h1&gt;
&lt;ol&gt;
 	&lt;li&gt;使用Matplotlib提供的bar()函数来绘制柱状图&lt;/li&gt;
 	&lt;li&gt;与plot()函数类似，程序每次调用bar()函数时都会生成一组柱状图，如果希望生成多组柱状图，则可通过多次调用bar()函数来实现&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs java&#34;&gt;bar(x,height,width=&lt;span class=&#34;hljs-number&#34;&gt;0.8&lt;/span&gt;,*,align=&lt;span class=&#34;hljs-string&#34;&gt;&#39;center&#39;&lt;/span&gt;,**kwargs)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;hljs-button {2}&#34; data-title=&#34;复制&#34;&gt;&lt;/div&gt;
&lt;ul&gt;
 	&lt;li&gt;x:包含所有柱子的下标的列表&lt;/li&gt;
 	&lt;li&gt;height：y轴的数值序列，也是柱状图的高度，一般就是我们需要展示的数据&lt;/li&gt;
 	&lt;li&gt;width：为柱状图的宽度，一般为0.8即可&lt;/li&gt;
 	&lt;li&gt;align：柱子对齐方式，center和edge。center表示每根柱子是根据下标来对齐，edge则表示每根柱子全部以下标为起点，然后显示到下标的右边。如果不指定该参数，默认值是center。&lt;/li&gt;
 	&lt;li&gt;color：每根柱子呈现的颜色，可指定一个固定的颜色或者一个列表&lt;/li&gt;
 	&lt;li&gt;edgecolor：每根柱子边框的颜色&lt;/li&gt;
 	&lt;li&gt;linewidth：每根柱子的边框宽度。如果没有设置该参数，默认无边框&lt;/li&gt;
 	&lt;li&gt;tick_label:每根柱子上显示的标签，默认无标签&lt;/li&gt;
 	&lt;li&gt;xerr：每根柱子顶部在横轴方向的线段长度&lt;/li&gt;
 	&lt;li&gt;yerr：每根柱子顶端在纵轴方向的线段长度&lt;/li&gt;
 	&lt;li&gt;ecolor：设置xerr和yerr的线段的颜色，可以指定一个固定值或者一个列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a name=&#34;t12&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t12&#34;&gt;&lt;/a&gt;简单柱状图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#简单柱状图
import matplotlib.pyplot as plt
num_list=[1.5,0.6,7.8,6]
plt.bar(range(len(num_list)),num_list)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t13&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t13&#34;&gt;&lt;/a&gt;设置柱子颜色&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#设置柱子的颜色
import matplotlib.pyplot as plt
num_list=[1.5,0.6,7.8,6]
plt.bar(range(len(num_list)),num_list,color=&#39;crgb&#39;)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t14&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t14&#34;&gt;&lt;/a&gt;设置标签&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#设置标签
import matplotlib.pyplot as plt
name_list=[&#39;Monday&#39;,&#39;Tuesday&#39;,&#39;Wednesday&#39;,&#39;Thursday&#39;]
num_list=[1.5,0.6,7.8,6]
plt.bar(range(len(num_list)),num_list,color=&#39;crgb&#39;,tick_label=name_list)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t15&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t15&#34;&gt;&lt;/a&gt;堆叠柱状图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs go&#34;&gt;#堆叠柱状图
import matplotlib.pyplot as plt
name_list = [&#39;Monday&#39;,&#39;Tuesday&#39;,&#39;Wednesday&#39;,&#39;Thursday&#39;]
num_list = [1.5,0.6,7.8,6]
num_list2 = [1,2,1,2]
plt.bar(range(len(num_list)),num_list,color=&#39;c&#39;,tick_label=name_list,label=&#39;boys&#39;)
plt.bar(range(len(num_list)),num_list2,color=&#39;m&#39;,tick_label=name_list,bottom=num_list,label=&#39;girls&#39;)
#bottom在第一个柱状图的基础
plt.legend()
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t16&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t16&#34;&gt;&lt;/a&gt;横向柱状图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs go&#34;&gt;#横向柱状图
import matplotlib.pyplot as plt
name_list = [&#39;Monday&#39;,&#39;Tuesday&#39;,&#39;Wednesday&#39;,&#39;Thursday&#39;]
num_list = [1.5,0.6,7.8,6]
num_list2 = [1,2,1,2]
plt.barh(range(len(num_list)),num_list,color=&#39;c&#39;,tick_label=name_list,label=&#39;boys&#39;)
plt.barh(range(len(num_list)),num_list2,color=&#39;m&#39;,tick_label=name_list,label=&#39;girls&#39;)
#bottom在第一个柱状图的基础
plt.legend()
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t17&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t17&#34;&gt;&lt;/a&gt;并列柱状图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#并列柱状图
import matplotlib.pyplot as plt
name_list = [&#39;Monday&#39;,&#39;Tuesday&#39;,&#39;Wednesday&#39;,&#39;Thursday&#39;]
num_list = [1.5,0.6,7.8,6]
num_list2 = [1,2,1,2]
x=list(range(len(num_list)))
total_width=0.8
n=2
width=total_width/2
plt.bar(x,num_list,color=&#39;c&#39;,tick_label=name_list,width=width,label=&#39;boys&#39;)
for i in range(len(x)):
    x[i]=x[i]+width
plt.bar(x,num_list2,color=&#39;m&#39;,tick_label=name_list,width=width,label=&#39;girls&#39;)
#bottom在第一个柱状图的基础
plt.legend(loc=&#39;best&#39;)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&lt;a name=&#34;t18&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t18&#34;&gt;&lt;/a&gt;饼状图&lt;/h1&gt;
&lt;ul&gt;
 	&lt;li&gt;饼状图显示一个系列中各项的大小与各项总和的比例&lt;/li&gt;
 	&lt;li&gt;饼状图可自动根据数据的百分比画饼&lt;/li&gt;
&lt;/ul&gt;
绘制饼状图的基本语法：
&lt;ol&gt;
 	&lt;li&gt;创建数组x的饼图，每个楔形的面积由x/sum(x)决定；&lt;/li&gt;
 	&lt;li&gt;若sum(x)&amp;lt;1,则x数组不会被标准化，x值即为楔形区域面积占比。注意，该种情况会出现1-sum(x)的空楔形&lt;/li&gt;
 	&lt;li&gt;若sum(x)&amp;gt;1,则由x[i]/sum(x)算出每个楔形占比，饼图360°区域均被填充&lt;/li&gt;
 	&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/biyoulin/p/9565350.html&#34; rel=&#34;nofollow&#34;&gt;pie函数精讲&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs vbscript&#34;&gt;def pie(x, explode=None, labels=None, colors=None, autopct=None,
        pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None,
        radius=None, counterclock=True, wedgeprops=None, textprops=None,
        center=(0, 0), frame=False, rotatelabels=False, hold=None, data=None)&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
 	&lt;li&gt;x：（创建饼状图的数据，每一块）的比例，如果sum(x)&amp;gt;1会使用sum(x)归一化；&lt;/li&gt;
 	&lt;li&gt;explode：（每一块）离开中心距离，一个list或数组&lt;/li&gt;
 	&lt;li&gt;labels：list、optional、default：none；为每个楔形添加标签&lt;/li&gt;
 	&lt;li&gt;color：array-like,optional,default:none;若无，则用currently active cycle中的颜色添加&lt;/li&gt;
 	&lt;li&gt;autopct:控制饼图内百分比设置，可以使用format字符串或者format function：可以是整数（&#39;%d%%&#39;）、浮点数（&#39;%1.3f%%&#39;）、字符串（&#39;%s%%&#39;）、函数。&lt;/li&gt;
 	&lt;li&gt;label distance:float,optional,default:1.1;label标记的绘图位置，相对于半径的比例，默认值为1.1，如&amp;lt;1则绘制饼图内侧&lt;/li&gt;
 	&lt;li&gt;pctdistance：float，optional，default：0.6；类似于labeldistance，指定autopct的位置刻度，默认值为0.6&lt;/li&gt;
 	&lt;li&gt;shadow：bool、optional、default：False；为饼图图画阴影（True）&lt;/li&gt;
 	&lt;li&gt;startangle：float，optional，default：none；起始绘制角度，默认图是从x轴正方向逆时针画起，如设定=90则从y轴正方向画起&lt;/li&gt;
 	&lt;li&gt;radius：float，optional，default：none；饼图的半径，若为none时，则默认为1&lt;/li&gt;
 	&lt;li&gt;counterclock：bool、optional、default：True；指定分数方向，逆时针True或顺时针&lt;/li&gt;
 	&lt;li&gt;wedgeprops：dict，optional，default：none；描述楔形边界线宽度值，参数形式“wedgeprops={‘linewidth’：3}”楔形边界线宽度为3&lt;/li&gt;
 	&lt;li&gt;textprops：dict、optional，default：none；传递给文本对象的字典参数&lt;/li&gt;
 	&lt;li&gt;center：list of float，optional，default：（0,0）；图标的中心为，默认（0,0），也可以是两个标量的序列（sequence of 2 scalars）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;import matplotlib.pyplot as plt
plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]
labels=&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;
sizes=[10,10,10,10]
plt.pie(sizes,labels=labels)
plt.title(&#39;简单饼状图&#39;)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t19&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t19&#34;&gt;&lt;/a&gt;一块饼图到中心的距离&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#explode参数：一块饼图到中心的距离，默认位0
import matplotlib.pyplot as plt
plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]
labels=&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;
sizes=[10,10,10,10]
#explode参数：一块饼图到中心的距离
explode=(0,0,0.1,0)
&lt;p&gt;plt.pie(sizes,labels=labels,explode=explode)&lt;br&gt;
plt.title(&#39;简单饼状图&#39;)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t20&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t20&#34;&gt;&lt;/a&gt; 标注每块饼图的颜色&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#colos：数组，可选参数，默认为none；用来标注每块饼图的Matplotlib颜色参数序列
import matplotlib.pyplot as plt
plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]
labels=&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;
sizes=[10,10,10,10]
color=[&#39;r&#39;,&#39;k&#39;,&#39;g&#39;,&#39;m&#39;]
#explode参数：一块饼图到中心的距离
explode=(0,0,0.1,0)
&lt;p&gt;plt.pie(sizes,labels=labels,explode=explode,colors=color)&lt;br&gt;
plt.title(&#39;简单饼状图&#39;)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;div class=&#34;hljs-button {2}&#34; data-title=&#34;复制&#34;&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a name=&#34;t21&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t21&#34;&gt;&lt;/a&gt;控制饼图内百分比设置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#autopct:控制饼图内百分比设置，可以使用format字符串或者format function
import matplotlib.pyplot as plt
plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]
labels=&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;
sizes=[10,10,10,10]
color=[&#39;r&#39;,&#39;c&#39;,&#39;g&#39;,&#39;m&#39;]
explode=(0,0,0.1,0)
&lt;p&gt;plt.pie(sizes,labels=labels,explode=explode,colors=color,autopct=&#39;%1.1f%%&#39;)&lt;br&gt;
plt.title(&#39;简单饼状图&#39;)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#x:每一块饼图的比例，为必填项，如果sum(x)&amp;gt;1,会将多余的部分进行均分
import matplotlib.pyplot as plt
plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]
labels=&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;
sizes=[0.1,0.2,0.3,0.2]
color=[&#39;r&#39;,&#39;c&#39;,&#39;g&#39;,&#39;m&#39;]
explode=(0,0,0.1,0)
 
plt.pie(sizes,labels=labels,explode=explode,colors=color,autopct=&#39;%1.1f%%&#39;)
plt.title(&#39;简单饼状图&#39;)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t22&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t22&#34;&gt;&lt;/a&gt;添加图例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#添加图例，ply.legend()
import matplotlib.pyplot as plt
plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]
labels=&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;
sizes=[0.1,0.2,0.3,0.2]
color=[&#39;r&#39;,&#39;c&#39;,&#39;g&#39;,&#39;m&#39;]
explode=(0,0,0.1,0)
&lt;p&gt;plt.pie(sizes,labels=labels,explode=explode,colors=color,autopct=&#39;%1.2f%%&#39;)&lt;br&gt;
plt.title(&#39;简单饼状图&#39;)&lt;br&gt;
plt.legend(loc=&amp;quot;upper right&amp;quot;,fontsize=8,borderaxespad = 0.3)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a name=&#34;t23&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t23&#34;&gt;&lt;/a&gt;雷达图&lt;/h1&gt;
&lt;ul&gt;
 	&lt;li&gt;雷达图（Rader Chart），又可称为戴布拉图、蜘蛛网图（Spider Chart），可以很好的刻画出某些指标的横向或纵向的对比关系&lt;/li&gt;
 	&lt;li&gt;雷达图常用于对比项指标的全面分析&lt;/li&gt;
 	&lt;li&gt;Python中用Matplotlib模块绘制雷达图需要用到极坐标系&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a name=&#34;t24&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t24&#34;&gt;&lt;/a&gt;polar函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;import numpy as np
import matplotlib.pyplot as plt
plt.polar(0.25*np.pi,20,&#39;ro&#39;,lw=2)
plt.ylim(0,50)
plt.show()
#0.25*np.pi:极角
#20：极径
#‘ro’:绘极坐标形状为红色圆点
#lw=2：极坐标图形宽度为2&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t25&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t25&#34;&gt;&lt;/a&gt;如果绘制多个极角和极轴&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;import numpy as np
import matplotlib.pyplot as plt
theta=np.array([0.25,0.5,0.75,1,1.25,1.5,1.75,2])
r=[75,60,50,70,50,85,45,70]
plt.polar(theta*np.pi,r,&#39;cs&#39;,lw=2)
plt.ylim(0,100)
#设置y轴的范围
plt.show()
#0.25*np.pi:极角
#20：极径
#‘ro’:绘极坐标形状为红色圆点
#lw=2：极坐标图形宽度为2&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t26&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t26&#34;&gt;&lt;/a&gt;闭合曲线&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#闭合曲线：多构造一个极坐标点，和第一个点重叠
import numpy as np
import matplotlib.pyplot as plt
theta=np.array([0.25,0.5,0.75,1,1.25,1.5,1.75,2,0.25])
r=[75,60,50,70,50,85,45,70,75]
#最后一个极坐标与第一个参数相同
plt.polar(theta*np.pi,r,&#39;cs--&#39;,lw=2)
plt.ylim(0,100)
#设置y轴的范围
plt.show()
#0.25*np.pi:极角
#20：极径
#‘ro’:绘极坐标形状为红色圆点
#lw=2：极坐标图形宽度为2&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t27&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t27&#34;&gt;&lt;/a&gt;Fill()函数填充雷达图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#fill()函数填充雷达图
import numpy as np
import matplotlib.pyplot as plt
theta=np.array([0.25,0.5,0.75,1,1.25,1.5,1.75,2,0.25])
r=[75,60,50,70,50,85,45,70,75]
#最后一个极坐标与第一个参数相同
plt.polar(theta*np.pi,r,&#39;cs--&#39;,lw=2)
plt.fill(theta*np.pi,r,facecolor=&#39;r&#39;,alpha=0.25)
#填充
plt.ylim(0,100)
#设置y轴的范围
plt.show()
#0.25*np.pi:极角
#20：极径
#‘ro’:绘极坐标形状为红色圆点
#lw=2：极坐标图形宽度为2&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t28&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t28&#34;&gt;&lt;/a&gt;学生成绩清单雷达图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;#导入库
import numpy as np
import matplotlib.pyplot as plt
#数据准备
courses=[&#39;Python&#39;,&#39;Java&#39;,&#39;C++&#39;,
         &#39;C&#39;,&#39;PHP&#39;,&#39;R&#39;,]
scores=[10,20,30,40,50,60]
datalength=len(scores)
#等分圆，曲线闭合
angles=np.linspace(0,2*np.pi,datalength,endpoint=False)
scores.append(scores[0])
angles=np.append(angles,angles[0])
#绘图
plt.polar(angles,scores,&#39;rv--&#39;,lw=2)
#设置标签
plt.thetagrids(angles*180/np.pi,courses,fontproperties=&#39;simhei&#39;)
#填充雷达图
plt.fill(angles,scores,facecolor=&#39;c&#39;,alpha=0.3)
&lt;p&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a name=&#34;t29&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t29&#34;&gt;&lt;/a&gt;三维图&lt;/h1&gt;
&lt;ul&gt;
 	&lt;li&gt;Matplotlib支持一些基础的三维图表绘制，需要使用mpl_toolkits模块&lt;/li&gt;
 	&lt;li&gt;在绘制三维图形时，至少需要指定x、y、z三个坐标轴的数据，然后再根据不同的图形类型指定额外的参数设置图形的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs&#34;&gt;plot_surface(X,Y,Z,*args,**kwargs)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;hljs-button {2}&#34; data-title=&#34;复制&#34;&gt;&lt;/div&gt;
&lt;ul&gt;
 	&lt;li&gt;常用参数：&lt;/li&gt;
 	&lt;li&gt;rstride和cstride分别控制x和y两个方向的步长，这决定了曲面上每个面片的大小&lt;/li&gt;
 	&lt;li&gt;color指定面片的颜色&lt;/li&gt;
 	&lt;li&gt;cmap指定面片的颜色映射表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a name=&#34;t30&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t30&#34;&gt;&lt;/a&gt;三维散点图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;p3d.Axes3D.scatter( xs, ys, zs=0, zdir=’z’, s=20, c=None, depthshade=True, 
                   *args, **kwargs )
&lt;p&gt;p3d.Axes3D.scatter3D( xs, ys, zs=0, zdir=’z’, s=20, c=None, depthshade=True,&lt;br&gt;
*args, **kwargs)&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li&gt;xs、ys、zs分别用来指定散点符号的x、y、z坐标，如果同时为标量则制定一个三点符号的坐标，如果同时为等长数组则指定一系列散点符号的坐标&lt;/li&gt;
 	&lt;li&gt;s用来指定散点符号的大小，可以是标量或与xs等长的数组&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a name=&#34;t31&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t31&#34;&gt;&lt;/a&gt;三维柱状图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;bar3d(self, x, y, z, dx, dy, dz, color=&lt;span class=&#34;hljs-keyword&#34;&gt;None&lt;/span&gt;, zsort=&lt;span class=&#34;hljs-string&#34;&gt;&#39;average&#39;&lt;/span&gt;, shade=&lt;span class=&#34;hljs-keyword&#34;&gt;True&lt;/span&gt;, lightsource=&lt;span class=&#34;hljs-keyword&#34;&gt;None&lt;/span&gt;, \*args, \*\*kwargs)[source]&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;hljs-button {2}&#34; data-title=&#34;复制&#34;&gt;&lt;/div&gt;
&lt;ul&gt;
 	&lt;li&gt;x、y、z分别用来表示每个柱底面的坐标，如果这三个参数都是标量则指定一个柱的底面坐标、如果是三个等长的数组则指定多个柱的底面坐标&lt;/li&gt;
 	&lt;li&gt;dx、dy、dz分别用来指定柱在三个坐标轴上的跨度，即x方向的宽度、y方向的厚度和z方向的高度&lt;/li&gt;
 	&lt;li&gt;color用来指定柱的表面颜色&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs python&#34;&gt;import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
&lt;p&gt;fig=plt.figure()&lt;br&gt;
ax=fig.gca(projection=&#39;3d&#39;)&lt;/p&gt;
&lt;p&gt;#测试数据&lt;br&gt;
theta=np.linspace(-4&lt;em&gt;np.pi,4&lt;/em&gt;np.pi,100)&lt;br&gt;
z=np.linspace(-4,4,100)&lt;em&gt;0.3&lt;br&gt;
r=z**4+1&lt;br&gt;
x=r&lt;/em&gt;np.sin(theta)&lt;br&gt;
y=r*np.cos(theta)&lt;/p&gt;
&lt;p&gt;ax.plot(x,y,z,&#39;b^-&#39;,label=&#39;3D Picture Test&#39;)&lt;br&gt;
mpl.rcParams[&#39;legend.fontsize&#39;]=20&lt;br&gt;
ax.legend(loc=&#39;best&#39;)&lt;br&gt;
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-report-view=&#34;{&amp;quot;mod&amp;quot;:&amp;quot;1585297308_001&amp;quot;,&amp;quot;dest&amp;quot;:&amp;quot;https://blog.csdn.net/weixin_43717681/article/details/106032827&amp;quot;,&amp;quot;extend1&amp;quot;:&amp;quot;pc&amp;quot;,&amp;quot;ab&amp;quot;:&amp;quot;new&amp;quot;}&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;原文：&lt;a href=&#34;https://blog.csdn.net/weixin_43717681/article/details/106032827&#34;&gt;https://blog.csdn.net/weixin_43717681/article/details/106032827&lt;/a&gt;&lt;/p&gt;
">Matplotlib库-Python数据可视化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/tan-suo-xing-shu-ju-fen-xi-edaexploratory-data-analysis/"" data-c="
          &lt;div id=&#34;content_views&#34; class=&#34;htmledit_views&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;EDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的主要工作是：对数据进行清洗，对数据进行描述（描述统计量，图表），查看数据的分布，比较数据之间的关系，培养对数据的直觉，对数据进行总结等。 &lt;/span&gt;&lt;/p&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;-&lt;span style=&#34;color: #000000;&#34;&gt;“探索性”指&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分析者对待解问题的理解会随着研究的深入不断&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;变化&lt;/span&gt;&lt;/div&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;基本步骤：&lt;/span&gt;&lt;/p&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;-&lt;span style=&#34;color: #000000;&#34;&gt;A. &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;检查&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;数据&lt;/span&gt;&lt;/div&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;-&lt;span style=&#34;color: #000000;&#34;&gt;B. &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;使用描述统计量和图表对数据进行&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;描述&lt;/span&gt;&lt;/div&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;-&lt;span style=&#34;color: #000000;&#34;&gt;C. &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;考察变量之间的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;关系&lt;/span&gt;&lt;/div&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;-&lt;span style=&#34;color: #000000;&#34;&gt;D. &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;检验特征分布&lt;/span&gt;&lt;/div&gt;
&lt;span style=&#34;color: #000000;&#34;&gt;                  -E.&lt;/span&gt; &lt;span style=&#34;color: #000000;&#34;&gt;其他&lt;/span&gt;
&lt;/div&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;&lt;/div&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;strong&gt;1.检查数据：&lt;/strong&gt;查看是否有缺失值，异常值，重复值等问题&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;数据类型分为&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;数值型，类别型，文本型，时间序列&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;等。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;主要考虑数值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;型（定量数据）和类别型（定性数据&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;       数值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;型又可以分为连续型和离散型。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;strong&gt;2.数据描述：&lt;/strong&gt;.describe()函数：&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;生成&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;描述性统计&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;数据&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;    &lt;span style=&#34;color: #000000;&#34;&gt;总结数据分布&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;集中趋势&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分散&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;和形状&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;不&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;包括 &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;NaN&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;值。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503121459924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;796&#34; height=&#34;535&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;strong&gt;3.特征相关性&lt;/strong&gt;：crosstab()共生矩阵/交叉表，用于统计分组频率的特殊透视表&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503121533376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;771&#34; height=&#34;361&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503123206352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;709&#34; height=&#34;428&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503123216670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;564&#34; height=&#34;234&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;strong&gt;4.特征分布&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503125732101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;750&#34; height=&#34;407&#34; /&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t1&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t1&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #000000;&#34;&gt;EDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;-&lt;span style=&#34;color: #0000ff;&#34;&gt;pandas&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;读取数据集&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;，显示&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;前&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;行&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;确认&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;是否&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;加载&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;正确&lt;/span&gt;&lt;/div&gt;
&lt;p style=&#34;margin-left: 1in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;必要时对列名重命名&lt;/span&gt;&lt;/p&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;-&lt;span style=&#34;color: #0000ff;&#34;&gt;查看&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;数据整体&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;情况&lt;/span&gt;&lt;/div&gt;
&lt;p style=&#34;margin-left: 1in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;行列数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;data.shape&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，数据类型&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;data.dtypes&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 1in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;data.info()&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;同时查看这两项&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 1in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;data.describe&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;查看连续变量的描述统计量&lt;/span&gt;&lt;/p&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;-&lt;span style=&#34;color: #0000ff;&#34;&gt;处理&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;缺失值，异常值，重复值&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;问题&lt;/span&gt;&lt;/div&gt;
&lt;p style=&#34;margin-left: 1in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;各&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;列分别有多少缺失值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;data.apply&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(lambda x: sum(&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;x.isnull&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;()),axis=0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 1in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;各&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;行分别有多少缺失值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;data.apply&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(lambda x: sum(&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;x.isnull&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;()),axis=1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 1in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;总共&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;有多少行有缺失&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;值&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 1in;&#34;&gt;    &lt;span style=&#34;color: #000000;&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;data.apply&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(lambda &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;x: sum(&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;x.isnull&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;()),axis=1).nonzero()[0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;])&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 1in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;删除&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;重复值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;data.drop_duplicates&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;()&lt;/span&gt;&lt;/p&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;-&lt;span style=&#34;color: #0000ff;&#34;&gt;分析特征之间相关性&lt;/span&gt;&lt;/div&gt;
&lt;span style=&#34;color: #0000ff;&#34;&gt;                  -检验数据分布&lt;/span&gt;
&lt;h1 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t2&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t2&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;创建新的特征&lt;/span&gt;&lt;/h1&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;当特征和目标变量并不是很&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;相关时，可以&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;修改输入的数据集，应用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;线性、非线性变换（或者其他相似方法）来&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;提高系统的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;精度。&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;数据是“死”的，人的思维是“活”的。数据科学家负责改变数据集和输入数据，使数据更好地符合分类模型。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;基本方法：&lt;/span&gt;&lt;/p&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;-&lt;span style=&#34;color: #000000;&#34;&gt;A. &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;特征的线性修正&lt;/span&gt;&lt;/div&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;                  -B. 特征的非线性修正&lt;/span&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t3&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t3&#34;&gt;&lt;/a&gt;1.特征的线性修正&lt;/h2&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t4&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t4&#34;&gt;&lt;/a&gt;&lt;strong&gt;1）回归问题&lt;/strong&gt;&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;从&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Sklearn&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;工具包中加载数据&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;——Python&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;命令直接加载&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503130143225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;721&#34; height=&#34;258&#34; /&gt;&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t5&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t5&#34;&gt;&lt;/a&gt;&lt;strong&gt;2-1）计算均方误差&lt;/strong&gt;&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;from sklearn.metrics import mean_squared_error&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;mean_squared_error(测试标签集，预测标签集)&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503130228898.png&#34; alt=&#34;&#34; width=&#34;535&#34; height=&#34;199&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;注意：不要混淆&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;MSE&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;MAE&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;RMSE（Root Mean Square Error）：均方根误差，衡量观测值与真实值之间的偏差，常用来作为机器学习模型预测结果衡量的标准。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;MSE（Mean square Error）：均方误差，真实值与预测值（估计值）差平方的期望。值越大，表明预测结果越差。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;MAE（Mean Absolute Error）：平均绝对误差，是所有单个观测值与算数平均值的偏差的绝对值的平均，可以更好的反应预测值误差的实际情况&lt;/span&gt;&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t6&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t6&#34;&gt;&lt;/a&gt;&lt;strong&gt;2-2）计算均方误差：Z-scores标准化&lt;/strong&gt;&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;（&lt;span style=&#34;color: #000000;&#34;&gt;Z-scores&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;标准化是将特征映射为均值为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、标准差为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的新&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;特征&lt;/span&gt;）&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503130415768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;578&#34; height=&#34;255&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;注意：&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;Z-scores&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;标准化属于线性变换&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;Z-Score通过（x-&lt;img class=&#34;mathcode&#34; src=&#34;https://private.codecogs.com/gif.latex?%5Cmu&#34; alt=&#34;\mu&#34; /&gt;）/&lt;img class=&#34;mathcode&#34; src=&#34;https://private.codecogs.com/gif.latex?%5Csigma&#34; alt=&#34;\sigma&#34; /&gt;将两组或多组数据转化为无单位的Z-Score分值（目的就是将不同量级的数据统一转化为同一个量级），使得数据标准统一化，提高了数据可比性，消弱了数据解释性。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;1）总体数据的均值（&lt;img class=&#34;mathcode&#34; src=&#34;https://private.codecogs.com/gif.latex?%5Cmu&#34; alt=&#34;\mu&#34; /&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;2）总体数据的标准差（&lt;img class=&#34;mathcode&#34; src=&#34;https://private.codecogs.com/gif.latex?%5Csigma&#34; alt=&#34;\sigma&#34; /&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;3）个体的观测值（x）&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;Z-Score本身没有实际意义，它的现实意义需要在比较中得以实现。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;估算Z-Score需要总体的平均值与方差，但是这一值在真实的分析与挖掘中很难得到，大多数情况下是用样本的均值与标准差替代。其次，Z-Score对于数据的分布有一定的要求，正态分布是最有利于Z-Score计算的。最后，Z-Score消除了数据具有的实际意义，A的Z-Score与B的Z-Score与他们各自的分数不再有关系，因此Z-Score的结果只能用于比较数据间的结果，数据的真实意义还需要还原原值。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;&lt;a href=&#34;https://blog.csdn.net/Orange_Spotty_Cat/article/details/80312154&#34;&gt;Z-Score标准化&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t7&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t7&#34;&gt;&lt;/a&gt;&lt;strong&gt;2-3）计算均方误差：鲁棒性缩放&lt;/strong&gt;&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;（&lt;span style=&#34;color: #000000;&#34;&gt;鲁棒&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;缩放采用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;中位数和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;IQR&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;对每个特征进行单独缩放&lt;/span&gt;）&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503130438988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;236&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;注意：鲁棒性缩放属于线性变换&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;鲁棒性：鲁棒是Robust（adj.强健的，健康的）的音译，它是在异常和危险情况下系统生存的关键，例如：计算机软件在输入错误、磁盘故障、网络过载或有意攻击情况下，能否不死机，不崩溃，就是该软件的鲁棒性。即控制系统在一定的参数变动下，维护其他某些性能的特性&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;鲁棒性缩放（RobustScaler）：采用中位数和IQR(四分位距)对每个特征进行单独缩放。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;由于数据读入缺失、传输错误或传感器损坏等原因，如果有一个或一些点原理中心，这些异常数据对均值和方差影响较大，但对中位数和四分位数影响不大，因此鲁棒缩放对于异常值更鲁棒&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E5%9B%9B%E5%88%86%E4%BD%8D%E8%B7%9D/10671363?fr=aladdin&#34; rel=&#34;nofollow&#34;&gt;四分位距-百度百科&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t8&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t8&#34;&gt;&lt;/a&gt;2.特征的非线性修正&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;创建新特征&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;例如：假定&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;输出结果与房屋&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;居住人数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;大致&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;相关&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;事实上&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，房屋&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;个人&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;居住&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;还是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;个人&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;居住，其价格会有很大&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;区别。&lt;/span&gt;&lt;/div&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;然而&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，同样的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;房子&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;个人&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;居住&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;12&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;个人&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;居住，其价格差别并不是很大（尽管仍然是两个人的差别）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/div&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;&lt;strong&gt;                  但我们可以将房屋占用率的平方根作为新特征&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;注意：numpy.&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;sqrt()&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;属于非线性变换&lt;/span&gt;&lt;/p&gt;
&lt;h1 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t9&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t9&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;维数约简&lt;/span&gt;&lt;/h1&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;当数据集中包含大量特征时：&lt;/span&gt;&lt;/p&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;有些&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;特征包含丰富的预测&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;信息；&lt;/span&gt;&lt;/div&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;有些&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;特征之间具有一定的相关性；&lt;/span&gt;&lt;/div&gt;
&lt;div style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;有些特征只&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;包含噪声或不相关&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;信息；&lt;/span&gt;&lt;/div&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;只&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;保留有意义的特征不仅可以使数据集易于管理，而且可以使预测结果不受数据中噪声的影响，预测精度更好。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;&lt;strong&gt;维数约减&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;消除&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;输入数据集的某些特征，创建一个&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;有限特征的数据集（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;包含所有需要的信息&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;），以&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;更有效的方式预测目标变量&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;注：多数维数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;约简&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;算法的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;一个主要&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;假设：&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;                                &lt;span style=&#34;color: #000000;&#34;&gt;数据&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;包含加性高斯&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;白噪声。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;      维数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;约&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;简可以减少噪声的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;集合&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;跨度，以此减少噪声&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;能量。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #86ca5e;&#34;&gt;噪声数据：是指数据中存在着错误或异常（偏离异常值）的数据，这些数据对数据分析造成了干扰。即无意义数据，现阶段的意义已经扩展到包含所有难以被机器正确理解和翻译的数据，如非结构化文本。任何不可被源程序读取和运用的数据，不管是已经接受、存贮的还是改变的，都成为噪声。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #e579b6;&#34;&gt;加性高斯白噪声（AWGN：Additive White Gaussian Noise）是最基本的噪声和干扰模型&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #e579b6;&#34;&gt;加性噪声：叠加在信号上的一种噪声，，通常记为n（t），而且无论有无信号，噪声n（t）都是始终存在的。因此通常称它为加性噪声或者加性干扰。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #e579b6;&#34;&gt;白噪声：噪声的功率谱密度在所有得频率上均为一个常数，则称这样的噪声为白噪声，如果白噪声取值的概率分布服从高斯分布，则称这样的噪声为高斯白噪声。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #e579b6;&#34;&gt;当波的功率频谱密度乘以一个适当的系数后将得到每单位频率波携带的功率，这被称为信号的功率谱密度。&lt;/span&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t10&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t10&#34;&gt;&lt;/a&gt;1.协方差矩阵&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;协方差&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是对两个随机变量&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;联合分布&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;线性相关程度的一种度量&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;随机变量&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Y&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的协方差：&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;                 &lt;img src=&#34;https://img-blog.csdnimg.cn/20200503103149947.png&#34; alt=&#34;&#34; width=&#34;385&#34; height=&#34;50&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;                   cov&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;(X, Y) =&lt;/strong&gt;&lt;/span&gt; &lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;cov&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;(Y, X) &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;随机变量&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;与自身&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的协方差&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;就是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;方差：&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;                   &lt;img src=&#34;https://img-blog.csdnimg.cn/20200503103241452.png&#34; alt=&#34;&#34; width=&#34;389&#34; height=&#34;37&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;                  &lt;img src=&#34;https://img-blog.csdnimg.cn/20200503103251447.png&#34; alt=&#34;&#34; width=&#34;389&#34; height=&#34;46&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;1-1）两个随机变量越线性相关，协方差越大&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;1-2）线性无关，协方差为0&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t11&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t11&#34;&gt;&lt;/a&gt;2.相关系数：&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;相关系数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(Correlation coefficient&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; 是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;按积差方法计算，同样以两变量与各自平均值的离差为基础，通过两个离差相乘来反映两变量之间相关&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;程度。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503103515174.png&#34; alt=&#34;&#34; width=&#34;558&#34; height=&#34;77&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;2-1）相关系数取值在-1~1之间&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;2-2）相关系数为0时，称两个变量不相关&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;2-3）相关系数为1，两个变量完全相关，即具有线性关系&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;2-4）越接近0，变量相似度越小&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;2-5）越接近1，变量相似度越大&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;2-6）相关系数&amp;gt;0.8，高度相关；相关系数&amp;lt;0.3，低度相关，其他中度相关&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #86ca5e;&#34;&gt;例子：&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #86ca5e;&#34;&gt;X=[1.1, 1.9, 3]
Y=[5.0, 10.4, 14.6]
X,Y的协方差计算：　&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #86ca5e;&#34;&gt;　    E(X) = (1.1+1.9+3)/3 =2
E(Y) = (5.0+10.4+14.6)/3 =10
E(XY)=(1.1×5.0+1.9×10.4+3×14.6)/3 = 23.02
Cov(X,Y)=E(XY)-E(X)E(Y) = 23.02-2×10 =3.02
X,Y的相关系数：&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #86ca5e;&#34;&gt;       D(X)=E(X^2)-E^2(X)=(1.1^2+1.9^2+3^2)/3 – 4 = 0.6 &lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #86ca5e;&#34;&gt;        σx=sqrt(D(X)) =0.77
D(Y)=E(Y^2)-E^2(Y)=(5^2+10.4^2+14.6^2)/3-100 = 15.44 &lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #86ca5e;&#34;&gt;       σy=sqrt(D(Y)) =3.93
r(X,Y)=Cov(X,Y)/(σxσy)=3.02/(0.77×3.93) = 0.9979&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;注意：不要混淆协防差矩阵cov()&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;和相关系数矩阵&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;corrcoef()&lt;/span&gt;&lt;/p&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503104344128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;752&#34; height=&#34;653&#34; /&gt;
&lt;p&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;相关矩阵也叫相关系数矩阵，其是由矩阵各列间的&lt;/span&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/3109424&#34; rel=&#34;nofollow&#34;&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;相关系数&lt;/span&gt;&lt;/a&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;构成的。也就是说，相关矩阵第i行第j列的元素是原矩阵第i列和第j列的相关系数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;两个矩阵都是对称矩阵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t12&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t12&#34;&gt;&lt;/a&gt;3.矩阵图形化：热力图heatmap()&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;import seaborn as sns&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;Import matplotlib.pyplot as plt&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;sns.heatmap(协方差矩阵，annot=True)&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;注意：参数&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;annot&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;默认&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;False&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;True&lt;/span&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;指的是热力图对应方格写入数据&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;相关特征可能包含相似属性，因而可以&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;约减高度相关特征&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;维数约减算法&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;有很多&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，如&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LFA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LSA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;ICA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;T-SNE&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;等。&lt;/span&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t13&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t13&#34;&gt;&lt;/a&gt;4.主成分分析PCA&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;主成分分析 &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Principal（主要的） Component（组成部分） Analysis, PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，又称主元分析、主分量&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分析，旨在利用降维的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;思想简化数据。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的主要思想&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;通过对原始变量相关矩阵内部结构的关系研究，找出影响效果某一要素的几个综合指标，使综合指标为原来变量的&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;线性拟合&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;将&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;m&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;维&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;特征映射&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;到&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;p&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;维&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;上，&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;这&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;p&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;维是新&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;的正交&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;特征，被&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;称为主&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;成分&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;维&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;特征&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;在&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;原有&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;m&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;维&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;特征的基础上重新构造出来&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的，&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;不仅保留了原始变量的主要信息，且彼此间不相关，又比原始变量具有某些更优越的性质&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;4-1）算法步骤：&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;·对所有的样本进行中心化，标准化，归一化，白化等&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;·计算样本的协方差矩阵&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;·对矩阵X&lt;img class=&#34;mathcode&#34; src=&#34;https://private.codecogs.com/gif.latex?X%5E%7BT%7D&#34; alt=&#34;X^{T}&#34; /&gt;特征值分解&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;·取出最大n个特征值对应的特征向量，标准化后组成特征向量矩阵W&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;·对样本转化&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;·得到输出样本&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;4-2）PCA常用参数（&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;PCA(&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;n_components&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;=None&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;, copy=True, whiten=False&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;·n_components=None 保留主成分个数，赋值为字符串自动选取。&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;类型：&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #000000;&#34;&gt;或者 &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，缺省时默认为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;None&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，所有成分被保留&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;赋值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，如&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;n_components&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;=1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，将把原始数据降到一个维&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;度；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;赋值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，如&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;n_components&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;=&#39;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;mle&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&#39;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，将自动选取特征个数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，使得满足所要求的方差百分比。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;·copy=True 是否复制原始训练数据&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;若&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;True&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;则&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;在原始数据的副本上进行&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;运算后&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，原始训练数据的值不会有任何改变&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;缺省时默认为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;True&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;若&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;False&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，则运行&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;算法后，原始训练数据&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的值改变。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;·whiten=False 白化，每个特征具有相同方差&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;·svd_solver=’full’ 指定奇异值分解SVD的方法，&lt;span style=&#34;color: #000000;&#34;&gt;有&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;个&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可选值：&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;{‘&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;auto’, ‘full’, ‘&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;arpack&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;’, ‘randomized&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;’}&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #86ca5e;&#34;&gt;SVD（奇异值分解）：通过SVD对数据的处理，我们&lt;/span&gt;&lt;span style=&#34;color: #e579b6;&#34;&gt;可以使用小得多的数据集来表示原始数据集&lt;/span&gt;&lt;span style=&#34;color: #86ca5e;&#34;&gt;，这实际上是去除了噪声和冗余信息，以此到达了优化数据，提高结果的目的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table style=&#34;width: 500px;&#34; border=&#34;1&#34; cellspacing=&#34;1&#34; cellpadding=&#34;1&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;优点：简化数据，去除噪声，提高算法的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺点：数据的转换可能难以理解&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;适用于数据类型：数值型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #7c79e5;&#34;&gt;&lt;strong&gt;Randomized PCA&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Scikit&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;-Learn&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;提供了一种基于随机&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;SVD&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Randomized SVD&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）的更快的算法，它是一种更&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;轻的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、近似迭代分解的方法&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;做矩阵分解时，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;随机&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;SVD&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;比经典&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;SVD&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;算法速度更快&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;只需&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;要几个步骤就能与经典算法结果极其近似。因此，当训练数据集很大时，它是一个很好的选择&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;当&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;数据集的规模非常&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;小时，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; Randomized PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;输出&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;结果与&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;经典&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;相当接近&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，但当&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;这两种算法应用于大数据集时，其对比结果会显著不同。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;4-3）举例&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;from sklearn.decomposition import PCA&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;pca=PCA(n_components=2)&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;pca.fit_transform(训练数据集)&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t14&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t14&#34;&gt;&lt;/a&gt;5.潜在因素分析LFA&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;一&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;科成绩好的学生，往往其他各科成绩也比较&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;好&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;→&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;学生&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的各科成绩之间存在着一定的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;相关 &lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;→&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是否&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;存在某些&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;潜在的共性&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;因子&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;影响&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;着学生的学习&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;成绩？&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;用潜在变量解释观察变量的数学模型称为潜变量模型&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;中每个主成分不具有特定的含义，为此提出了&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;因子分析，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;通过&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;寻找潜在因子获得观测变量的潜在&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;结构&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，即潜&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;变量分析 &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(Latent Factor（潜在因素）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; Analysis, LFA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;LFA主要目的是用来描述隐藏在测量变量中的一些更基本，但又无法直接测量到的隐性变量。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LFA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;不需要对输入信号进行正交分解，其算法假设是：数据中的观测变量是潜变量经过线性变换后的值，并且具有可分离的噪声（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;AWG&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;任意波形发生器生成的噪声）。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/2020050311103359.png&#34; alt=&#34;&#34; width=&#34;923&#34; height=&#34;114&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503113937959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;499&#34; height=&#34;338&#34; /&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t15&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t15&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #3399ea;&#34;&gt;6.线性判别分析LDA&lt;/span&gt;&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;线性&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;判别分析&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(Linear（线性的） Discriminant（判别式） Analysis&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;一种经典的线性&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;学习方法，试图&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;找到两类&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;物体&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;事件特征&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的一个线性组合，以能够特征化或区分它们&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是线性&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分类器&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;也可以&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;为分类&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;做降维处理&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;1.算法思想：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;给定&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;训练样例集，设法将样例投影到一条直线上，使得&lt;/span&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;同类样例的投影点尽可能接近，异样样例的投影点尽可能远离&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;；在对新样本进行分类时，将其投影到同样的直线上，再根据投影点的位置来确定新样本的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;类别。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503113912127.png&#34; alt=&#34;&#34; width=&#34;947&#34; height=&#34;117&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503113955431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;420&#34; height=&#34;274&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503111455920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;421&#34; height=&#34;325&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503112315441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;765&#34; height=&#34;483&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503112341862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;728&#34; height=&#34;446&#34; /&gt;&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t16&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t16&#34;&gt;&lt;/a&gt;2.LDA与PCA区别&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503113155962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;379&#34; height=&#34;269&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA（主成分分析）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;寻找数据集中方差最大的方向作为主成分分量的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;轴，为了&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;方差最大化&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;→ 投影到左边&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA（线性判别分析）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;投影后类内方差最小，类间方差最大&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;→ 投影到下面&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;相同点&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;：（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）均&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可以对数据进行降&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;维；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;               （&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;均&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;使用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;了矩阵特征分解的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;思想&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;               &lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;均&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;假设&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;数据符合高斯分布&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;不同点&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;： （&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;） &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是有&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;监督降维，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是无&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;监督降维；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;               &lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;） &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;降维最多降到类别数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;k-1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;维度，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;没有该限制；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;               （&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;） &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;于降维，还&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;于&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分类；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;               &lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;选择分类性能最好的投影方向&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .31in;&#34;&gt; &lt;span style=&#34;color: #000000;&#34;&gt;                       PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;选择样本点&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;投影&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;具有&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;最大方差的方向。&lt;/span&gt;&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t17&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t17&#34;&gt;&lt;/a&gt;3.LDA优点与缺点&lt;/h3&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t18&#34;&gt;&lt;/a&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503113451886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;329&#34; height=&#34;261&#34; /&gt;&lt;/h2&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503113500191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;317&#34; height=&#34;274&#34; /&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可以&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;使用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;类别先验知识，无监督学习无法&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;使用类别先验知识。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）样本&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分类信息依赖均值而不是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;方差时，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;比&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;算法&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;较优&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;不适合对非高斯分布样本进行降维，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;也有这个&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;问题&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）若降维维&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;度大于&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;k-1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，不能&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;使用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（有一些&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的进化版可以&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;绕过这个问题）；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;在样本分类信息依赖方差而不是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;均值时，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;降维效果&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;不好；&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可能过度拟合数据。&lt;/span&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t19&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t19&#34;&gt;&lt;/a&gt;7.潜在语义分析LSA&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;潜在&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;语义分析&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(Latent &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Semantical&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; Analysis&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LSA)&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;一种&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;信息检索模型，使用统计方法&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;对&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;大量文本&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;集进行分析&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #002368;&#34;&gt;&lt;strong&gt;提取词&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002368;&#34;&gt;&lt;strong&gt;与词之间潜在的语义结构&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;并用提取的潜在语义结构表示&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;词和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;文本，&lt;/span&gt;&lt;span style=&#34;color: #984807;&#34;&gt;&lt;strong&gt;消除&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #984807;&#34;&gt;&lt;strong&gt;词之间的相关性和简化文本&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #984807;&#34;&gt;&lt;strong&gt;向量&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，实现&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;降维的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;目的，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;通常&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;应用于经过&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;TfidfVectorizer&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;或&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;CountVectorizer&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;处理的文本分析中&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0in;&#34;&gt;&lt;a name=&#34;t20&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t20&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;1.基本思想：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;把高维向量空间模型表示中的文档映射到低维的潜在语义空间中&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，这个&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;映射是通过对项&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;文档&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;矩阵&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（输入数据集通常是一个稀疏矩阵）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的奇异值分解来实现，&lt;/span&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;产生具有相同概念词语的语义集合。&lt;/span&gt;&lt;/p&gt;
&amp;nbsp;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t21&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t21&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.CountVectorize&lt;/strong&gt;&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;只考虑词汇在文本中出现的频率&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t22&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t22&#34;&gt;&lt;/a&gt;&lt;strong&gt;3.TfidfVectorizer&lt;/strong&gt;&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;考虑词汇在文本出现的频率，并关注包含该词汇的所有文本的数量，能够削减高频没有意义的词汇出现带来的影响&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;, &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;挖掘更有意义的特征&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503114407790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;896&#34; height=&#34;259&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503114423335.png&#34; alt=&#34;&#34; width=&#34;755&#34; height=&#34;67&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Truncated SVD &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;截断&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;SVD&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的变形&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，对样本矩阵进行分解，只&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;计算用户指定的最大的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;K&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;个&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;奇异值。&lt;/span&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t24&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t24&#34;&gt;&lt;/a&gt;8.独立成分分析ICA&lt;/h2&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t25&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t25&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #333333;&#34;&gt;&lt;strong&gt;1.基本概念&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #333333;&#34;&gt;独立成分&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;分析&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;(Independent Component &lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;Analysis&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;ICA)&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;是从多维统计&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;数据中寻找潜在因子或成分的一种&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;span style=&#34;color: #333333;&#34;&gt;ICA&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;与&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;其它方法的重要区别&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;在于&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;，寻找&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;满足&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;统计独立&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;非高斯&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;的成分&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t26&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t26&#34;&gt;&lt;/a&gt;2.ICA与PCA区别&lt;/h3&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;span style=&#34;color: #333333;&#34;&gt;PCA &lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;假设&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;源信号间彼此非相关&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;ICA &lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;假设&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;源信号间彼此&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;独立；&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;span style=&#34;color: #333333;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;认为&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;主元之间彼此正交，样本呈高斯分布&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;； ICA则&lt;/span&gt;&lt;span style=&#34;color: #333333;&#34;&gt;不要求样本呈高斯分布。&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503115005354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;523&#34; height=&#34;391&#34; /&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/2020050311501388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;372&#34; height=&#34;245&#34; /&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503115020911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;492&#34; height=&#34;238&#34; /&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503115108814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;372&#34; height=&#34;242&#34; /&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503115126215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;615&#34; height=&#34;325&#34; /&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503115150800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;428&#34; height=&#34;280&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t28&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t28&#34;&gt;&lt;/a&gt;9.核主成分分析Kernel PCA&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;核主成分分析&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(Kernel PCA)&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的扩展，&lt;/span&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;通过非线性映射将数据转换到一个高维空间中，在高维空间中使用PCA进行降维。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;引入&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;非线性映射&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;函数，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;将原空间中的数据映射到高维空间，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;em&gt;∅&lt;/em&gt;&lt;/span&gt;∅&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;隐函数&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;引入一个定理&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;：空间中的任一&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;向量都&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可以由该空间中的所有样本线性&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;表示&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;核函数：通过两个向量点积来度量向量间相似度的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;函数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;通过使用核技巧&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，可以&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;在原始特征空间中计算两个高维特征空间中向量的相似度。&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;最&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;常用的内核有&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;linear&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;poly&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;RBF&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;sigmoid&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;cosine&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&amp;nbsp;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503115445248.png&#34; alt=&#34;&#34; width=&#34;918&#34; height=&#34;190&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503115455797.png&#34; alt=&#34;&#34; width=&#34;926&#34; height=&#34;106&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503115506998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;352&#34; height=&#34;242&#34; /&gt;变为&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503115518195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;363&#34; height=&#34;235&#34; /&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t29&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t29&#34;&gt;&lt;/a&gt;10.T-分布邻域嵌入算法 T-SNE&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;T-&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分布领域&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;嵌入 &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(T-distributed &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Stochastic Neighbor &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Embedding&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;T-SNE )&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;算法&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;目前一个非常流行的&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;对高维度数据&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;进行非线性降&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;维&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;算法。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;基本思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;高维特征空间在二维&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;平面&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;三维超平面上&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;寻找一个投影，使得在原本的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;维空间中相距很远的数据点&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;在&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;平面&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;上&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;同样相距较远，而原本相近的点在平面上仍然相近&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;本质&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;上&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;领域&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;嵌入寻找 &lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;保留样本&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;的邻居关系&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;的 &lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;新的&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;低&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;维度数据&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;表示&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;为高维特征空间在二维三维平面上寻找投影，使近的还是近，远的还是远，保留邻居关系，用新的低维度数据表示&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;算法规则：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;递归的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;相似观测必须对输出有更大的贡献&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt; &lt;span style=&#34;color: #000000;&#34;&gt;                                              ——&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;用概率分布函数实现；&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;高&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;维空间的分布必须与低维空间的分布相似&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span style=&#34;color: #000000;&#34;&gt;                                              —— &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;用最小化&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;KL&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;距离实现；&lt;/span&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t30&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t30&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #3399ea;&#34;&gt;11.受限玻尔兹曼机 RBM&lt;/span&gt;&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;玻尔兹曼机&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Boltzman&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; machine&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;BM)&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; 是一种基于能量函数的建模方法，能够描述变量之间的高阶相互作用，所建模型和学习算法有比较完备的物理解释和严格的数理统计理论作基础。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;BM&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是一&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;种&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;二值型（&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;或&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;随机神经网络&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;由&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可见层&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;和隐&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;层&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;组成&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;网络&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;节点分为&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;可见单元&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(visible unit)&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;隐单元&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(hidden unit&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;)&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;通过权&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;值表达单元之间的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;相关性&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;使用了&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;玻尔兹曼分布&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;作为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;激活函数&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;原理是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;模拟退火&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;算法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: .81in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503120015713.png&#34; alt=&#34;&#34; width=&#34;246&#34; height=&#34;245&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;V表示所有可见单元，h表示所有隐单元&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .81in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503120108548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;637&#34; height=&#34;263&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;层间、层内全连接&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;受限玻尔兹曼机(Restricted BM，RBM)是BM的一种特殊拓扑结构：&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;&lt;strong&gt;RBM是一个概率模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;RBM是结合线性函数（隐层神经元）对输入数据进行&lt;strong&gt;非线性变换&lt;/strong&gt;的方法&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .81in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503120155661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;552&#34; height=&#34;227&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: .81in;&#34;&gt;层间全连接、层内无连接&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;当&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;给定可见层&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;神经元状态&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;时&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;         各隐层神经元之间&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是否&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;激活条件独立；&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .31in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;当给定隐层神经元状态&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;时&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;         各&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可见&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;层神经元之间&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是否&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;激活条件独立。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503120707962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;879&#34; height=&#34;364&#34; /&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503120734631.png&#34; alt=&#34;&#34; width=&#34;289&#34; height=&#34;296&#34; /&gt;&lt;/p&gt;
&lt;h1 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t31&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t31&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;异常数据的检测与处理&lt;/span&gt;&lt;/h1&gt;
&lt;span style=&#34;color: #000000;&#34;&gt;样本中&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;显著偏离其他&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;数值的数据称为&lt;/span&gt;&lt;span style=&#34;color: #a50021;&#34;&gt;&lt;strong&gt;异常值（&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #a50021;&#34;&gt;&lt;strong&gt;Outlier&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #a50021;&#34;&gt;&lt;strong&gt;），&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;其他预期的观测值标记为正常值或内点（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Inlier&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;
&lt;h2&gt;&lt;a name=&#34;t32&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t32&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #000000;&#34;&gt;单变量异常检测&lt;/span&gt;&lt;/h2&gt;
&lt;h3 style=&#34;margin-left: 0in;&#34;&gt;&lt;a name=&#34;t33&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t33&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #000000;&#34;&gt;什么是极端值？&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .88in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;使用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Z-scores&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;时，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;得分绝对值高于&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;观测值为可疑异常值&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .88in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;如果观测量是数据描述&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，以下&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;两种数据当作可疑异常值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: 1.38in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;第一&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;种是比&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;25&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分位值减去&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;IQR*1.5&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;小的观测&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;量&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: 1.38in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;第二&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;种是比&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;75&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分位值加上&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;IQR*1.5&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;大的观测&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;               注：&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;IQR(Inter quartile &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;range&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;四分位&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;距，即&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;75&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分位值与&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;25&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分位值的差。&lt;/span&gt;&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0in;&#34;&gt;&lt;a name=&#34;t34&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t34&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #000000;&#34;&gt;如何&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;使用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Z-scores&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;检测异常值？&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .88in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;使用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;sklearn&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;中&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;StandardScaler&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;函数对所有连续变量进行&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;标准化&lt;/span&gt;，&lt;span style=&#34;color: #000000;&#34;&gt;找到那些绝对值大于&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;倍标准差的值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;单&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;变量方法可以检测出相当&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;多潜在&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;异常值，但是，它不能检测那些不是极端值的异常值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0in;&#34;&gt;&lt;a name=&#34;t35&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t35&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #000000;&#34;&gt;如果变量本身不是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;极端&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;值，而它与其它&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;变量&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;或&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;多个&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;变量组合后出现&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;不&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;正常值，如何检测？&lt;/span&gt;&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;——&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可以先使用维数约简算法，再检查绝对值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;超过三倍标准偏差的成分&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Scikit&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;-learn&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;库提供了可直接使用并&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;自动标出所有&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可疑实例的类：&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;&lt;span style=&#34;color: #000000;&#34;&gt;covariance.EllipticEnvelope&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;类&lt;/span&gt;&lt;/strong&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;：&lt;/strong&gt;适合&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;鲁棒的数据分布估计，由于异常值是数据总体分布中的极值点，它能够指出数据中的异常值。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;&lt;span style=&#34;color: #000000;&#34;&gt;svm.OneClassSVM&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;类&lt;/span&gt;&lt;/strong&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;：&lt;/strong&gt;可以&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;模拟数据的形状，找出任何新的实例是否属于原来的类&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（默认&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;情况下假定&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;数据中&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;没有异常值）&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。修改&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;其&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;参数后能&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;作用于有异常值的数据集，比&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;EllipticEnvelope&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;系统更强大、更可靠&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t36&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t36&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #000000;&#34;&gt;EllipticEnvelope&lt;/span&gt;&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;假设&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;全部数据可以表示成基本的多元高斯分布，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;EllipticEnvelope&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;函数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;试图&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;找出数据总体分布关键&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;参数。&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;尽可能简化算法背后的复杂估计，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可认为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;该算法主要&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;检查&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;每个观测量与总均值的距离&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;由于总&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;均值要考虑数据&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;集中所有&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;变量&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，该&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;算法能够同时发现单变量和多变量的异常值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Covariance.EllipticEnvelope&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;函数使用时需要考虑污染参数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;contamination parameter&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; ，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;该&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;参数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;异常值在数据集中的&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;strong&gt;比例&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，默认&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;取值为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0.1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，最高&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;取值为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0.5&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;注：鉴于标准正态分布&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;中观测值落在距离均值大于&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Z-score&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;距离）区域的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;百分比是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0.01-0.02&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;作为初始值，建议污染参数取值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0.01-0.02&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;EllipticEnvelope&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;算法的&lt;/strong&gt;&lt;/span&gt;&lt;span style=&#34;color: #002f8e;&#34;&gt;&lt;strong&gt;局限性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;EllipticEnvelope&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;函数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;适用于&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;有控制参数的高斯分布假设，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;使用时&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;要&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;注意：非&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;标化的数据、二值或分类数据与连续数据混合使用可能引发错误和估计不准确。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;EllipticEnvelope&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;函数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;假设全部数据可以表示成基本的多元高斯分布，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;当&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;数据中有多个分布&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;时，算法&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;试图将数据适应一个总体分布，倾向于寻找最偏远聚类中的潜在异常值，而忽略了数据中其他&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可能受&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;异常值影响的区域&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2 style=&#34;margin-left: 0in;&#34;&gt;&lt;a name=&#34;t37&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t37&#34;&gt;&lt;/a&gt; &lt;span style=&#34;color: #000000;&#34;&gt;OneClassSVM&lt;/span&gt;&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;OneClassSVM&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是一种机器学习&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;通过&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;学习知道数据应该服从什么&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分布&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;适用于&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;具有更多变量的数据&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;集&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;检查&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;新的样本是否符合以前的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;数据分布&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;参数&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;有&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;kernel&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;degree&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;gamma&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;nu&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Kernel&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Degree&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;：这两&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;个参数是&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;相关&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的，&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;           &lt;span style=&#34;color: #000000;&#34;&gt;通常&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;建议取默认&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;值&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;kernel&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;rbf&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;degree&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Gamma&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;：与&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;rbf&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;核相关的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;参数，建议设置&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;越低越好。&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .81in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Nu&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;： 决定模型是否必须符合一个精确的&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分布，&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: .5in;&#34;&gt;           &lt;span style=&#34;color: #000000;&#34;&gt;如果&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;有异常值存在&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Nu&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是必选参数。如果异常值比例&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;很小，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;则&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Nu&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;也会很小&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，反之很大。&lt;/span&gt;&lt;/p&gt;
&lt;h1 style=&#34;margin-left: .5in;&#34;&gt;&lt;a name=&#34;t38&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t38&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;验证指标&lt;/span&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;a name=&#34;t39&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t39&#34;&gt;&lt;/a&gt;使用scikit-learn构建模型&lt;/h2&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t40&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t40&#34;&gt;&lt;/a&gt;&lt;strong&gt;1.加载datasets模块中数据集&lt;/strong&gt;&lt;/h3&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t41&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t41&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.将数据集划分为训练集和测试集 train_test_split()&lt;/strong&gt;&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;在数据分析过程中，为了保证模型在实际系统中能够起到预期作用，一般需要将样本分成独立的三部分：&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .79in;&#34;&gt;训练集（train set）：用于估计模型。&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .79in;&#34;&gt;验证集（validation set)：用于确定网络结构或者控制模型复杂程度的参数。&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .79in;&#34;&gt;测试集（test set）：用于检验最优的模型的性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&#34;margin-left: .3in;&#34;&gt;典型的划分方式是训练集占总样本的50％，而验证集和测试集各占25％。&lt;/div&gt;
&lt;div style=&#34;margin-left: .3in;&#34;&gt;&lt;/div&gt;
&lt;div style=&#34;margin-left: .3in;&#34;&gt;
&lt;p&gt;&lt;strong&gt;train_test_split函数：&lt;/strong&gt;&lt;/p&gt;
&lt;div style=&#34;margin-left: .3in;&#34;&gt;sklearn的model_selection模块提供了train_test_split函数，能够对数据集进行拆分，其使用格式如下。&lt;/div&gt;
&lt;p style=&#34;margin-left: .39in;&#34;&gt;&lt;em&gt;sklearn.model_selection.&lt;/em&gt;&lt;strong&gt;&lt;em&gt;train_test_split&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;(*arrays, **options)&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 135pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;参数名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 135pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;*arrays&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;接收一个或多个数据集。代表需要划分的数据集，若为分类回归则分别传入数据和标签，若为聚类则传入数据。无默认。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 135pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;test_size&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;接收&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;None&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;类型的数据。代表测试集的大小。如果传入的为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;类型的数据则需要限定在&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0-1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;之间，代表测试集在总数中的占比；如果传入为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;类型的数据，则表示测试集记录的绝对数目。该参数与&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;train_size&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可以只传入一个。在&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0.21&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;版本前，若&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;test_size&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;train_size&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;均为默认则&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;testsize&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;25%&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 135pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;train_size&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;接收&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;None&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;类型的数据。代表训练集的大小。该参数与&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;test_size&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可以只传入一个。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 135pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;random_state&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;接收&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。代表随机种子编号，相同随机种子编号产生相同的随机结果，不同的随机种子编号产生不同的随机结果。默认为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;None&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 135pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;shuffle&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;接收&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;boolean&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。代表是否进行有放回抽样。若该参数取值为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;True&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;则&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;stratify&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;参数必须不能为空。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 135pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #ffffff;&#34;&gt;stratify&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;接收&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;array&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;或者&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;None&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;。如果不为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;None&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;，则使用传入的标签进行分层抽样。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div style=&#34;margin-left: .3in;&#34;&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .4in;&#34;&gt;&lt;span style=&#34;color: #ffffff;&#34;&gt;Ø&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;train_test_split&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;函数根据传入的数据，分别将传入的数据划分为训练集和测试集。&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .4in;&#34;&gt;&lt;span style=&#34;color: #ffffff;&#34;&gt;Ø&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;如果传入的是&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;组数据，那么生成的就是这一组数据随机划分后训练集和测试集，总共&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;组。如果传入的是&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;组数据，则生成的训练集和测试集分别&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;组，总共&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;组。&lt;/span&gt;&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .4in;&#34;&gt;&lt;span style=&#34;color: #ffffff;&#34;&gt;Ø&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;train_test_split&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;是最常用的数据划分方法，在&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;model_selection&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;模块中还提供了其他数据集划分的函数，如&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;PredefinedSplit&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;ShuffleSplit&lt;/span&gt;&lt;span style=&#34;color: #c00000;&#34;&gt;等。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;&lt;strong&gt;3.K折交叉验证法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .3in;&#34;&gt;当数据总量较少的时候，使用上面的方法将数据划分为三部分就不合适了。&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .3in;&#34;&gt;常用的方法是留少部分做测试集，然后对其余N个样本采用K折交叉验证法，基本步骤如下：&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .79in;&#34;&gt;将样本打乱，均匀分成K份。&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .79in;&#34;&gt;轮流选择其中K－1份做训练，剩余的一份做验证。&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .79in;&#34;&gt;计算预测误差平方和，把K次的预测误差平方和的均值作为选择最优模型结构的依据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t42&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t42&#34;&gt;&lt;/a&gt;&lt;strong&gt;4.使用sklearn转换器进行数据预处理与降维&lt;/strong&gt;&lt;/h3&gt;
&lt;strong&gt;sklearn转换器三个方法&lt;/strong&gt;
&lt;p&gt;sklearn把相关的功能封装为转换器（transformer）。使用sklearn转换器能够实现对传入的NumPy数组进行标准化处理，归一化处理，二值化处理，PCA降维等操作。转换器主要包括三个方法：&lt;/p&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 116pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;方法名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 116pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;fit&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;fit&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;方法主要通过分析特征和目标值，提取有价值的信息，这些信息可以是统计量，也可以是权值系数等。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 116pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;transform&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;transform&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;方法主要用来对特征进行转换。从可利用信息的角度可分为无信息转换和有信息转换。无信息转换是指不利用任何其他信息进行转换，比如指数和对数函数转换等。有信息转换根据是否利用目标值向量又可分为无监督转换和有监督转换。无监督转换指只利用特征的统计信息的转换，比如标准化和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;PCA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;降维等。有监督转换指既利用了特征信息又利用了目标值信息的转换，比如通过模型选择特征和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;LDA&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;降维等。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 116pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;fit_transform&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;fit_transform&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;方法就是先调用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;fit&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;方法，然后调用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;transform&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;sklearn部分预处理函数与其作用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table style=&#34;width: 518pt;&#34; border=&#34;1&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 232pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;函数名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 285pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 232pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;MinMaxScaler&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 285pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;对特征进行离差标准化。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 232pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;StandardScaler&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 285pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;对特征进行标准差标准化。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 232pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;Normalizer&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 285pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;对特征进行归一化。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 232pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;Binarizer&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 285pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;对定量特征进行二值化处理。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 232pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;OneHotEncoder&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 285pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;对定性特征进行独热编码处理。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 232pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;FunctionTransformer&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 285pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;对特征进行自定义函数变换。 &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;a name=&#34;t43&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t43&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;a name=&#34;t44&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t44&#34;&gt;&lt;/a&gt;构建并评价聚类模型&lt;/h2&gt;
聚类的输入是一组未被标记的样本，聚类根据数据自身的距离或相似度将他们划分为若干组，划分的原则是组内样本最小化而组间（外部）距离最大化，如图所示。
&lt;img src=&#34;https://img-blog.csdnimg.cn/2020050314333865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;621&#34; height=&#34;339&#34; /&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t45&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t45&#34;&gt;&lt;/a&gt;1、聚类方法类别&lt;/h3&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 187pt;&#34;&gt;&lt;strong&gt;算法类别&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;包括的主要算法&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 187pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;划分（分裂）方法&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;K-Means算法（K-平均），K-MEDOIDS算法（K-中心点）和CLARANS算法（基于选择的算法）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 187pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;层次分析方法&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;BIRCH算法（平衡迭代规约和聚类），CURE算法（代表点聚类）和CHAMELEON算法（动态模型）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 187pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;基于密度的方法&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;DBSCAN算法（基于高密度连接区域），DENCLUE算法（密度分布函数）和OPTICS算法（对象排序识别）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 187pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;基于网格的方法&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;STING&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;算法（统计信息网络），&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;CLIOUE&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;算法（聚类高维空间）和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;WAVE-CLUSTER&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;算法（小波变换）。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t46&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t46&#34;&gt;&lt;/a&gt;2、聚类算法模块cluster提供的聚类算法&lt;/h3&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 130pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;函数名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 120pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 160pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;适用范围&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 130pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;距离度量&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 152pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;KMeans&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 147pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;簇数&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 218pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;可用于样本数目很大，聚类数目中等的场景。&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 172pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;点之间的距离&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 152pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;Spectral clustering&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 147pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;簇数&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 218pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;可用于样本数目中等，聚类数目较小的场景。&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 172pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;图距离&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 152pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;Ward hierarchical clustering&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 147pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;簇数&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 218pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;可用于样本数目较大，聚类数目较大的场景。&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 172pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;点之间的距离&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 152pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Agglomerative clustering&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 147pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;簇数，链接类型，距离&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 218pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可用于样本数目较大，聚类数目较大的场景。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 172pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;任意成对点线图间的距离&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 152pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;DBSCAN&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 147pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;半径大小，最低成员数目&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 218pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可用于样本数目很大，聚类数目中等的场景。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 172pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;最近的点之间的距离&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 152pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Birch&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 147pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分支因子，阈值，可选全局集群&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 218pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可用于样本数目很大，聚类数目较大的场景。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 172pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;点之间的欧式距离3、&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t47&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t47&#34;&gt;&lt;/a&gt;3、sklearn估计器estimator的方法&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;聚类算法实现需要sklearn估计器（estimator）。sklearn估计器和转换器类似，拥有fit和predict两个方法。两个方法的作用如下。&lt;/p&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 97pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;方法名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 97pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;fit&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;fit方法主要用于训练算法。该方法可接收用于有监督学习的训练集及其标签两个参数，也可以接收用于无监督学习的数据。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 97pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;predict&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;predict用于预测有监督学习的测试集标签，亦可以用于划分传入数据的类别。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 style=&#34;margin-left: 0in;&#34;&gt;&lt;a name=&#34;t48&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t48&#34;&gt;&lt;/a&gt;&lt;strong&gt;4、聚类模型评价指标&lt;/strong&gt;&lt;/h3&gt;
聚类评价的标准是组内的对象相互之间是相似的（相关的），而不同组中的对象是不同的（不相关的）。即组内的相似性越大，组间差别越大，聚类效果就越好。sklearn的metrics模块提供的聚类模型评价指标。
&lt;div class=&#34;table-box&#34;&gt;
&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 180pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;方法名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 60pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;真实值&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 110pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;最佳值&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 200pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;sklearn函数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 252pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;ARI评价法（兰德系数）&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 68pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;需要&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 119pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;1.0&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;adjusted_rand_score&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 252pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;AMI&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;评价法（互信息）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 68pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;需要&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 119pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;adjusted_mutual_info_score&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 252pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;V-measure&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;评分&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 68pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;需要&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 119pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;completeness_score&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 252pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;FMI&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;评价法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 68pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;需要&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 119pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;fowlkes_mallows_score&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 252pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;轮廓系数评价法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 68pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;不需要&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 119pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;畸变程度最大&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;silhouette_score&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 252pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Calinski-Harabasz&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;指数评价法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 68pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;不需要&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 119pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;相较最大&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;calinski_harabaz_score&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t49&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t49&#34;&gt;&lt;/a&gt;构建并评价分类模型&lt;/h2&gt;
&lt;h3&gt;&lt;a name=&#34;t50&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t50&#34;&gt;&lt;/a&gt;&lt;strong&gt;sklearn库常用分类算法函数&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 100pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;模块名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 200pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;函数名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 100pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;算法名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 100pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;linear_model&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 200pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;LogisticRegression&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 100pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;逻辑斯蒂回归&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 186pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;svm&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;SVC&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 184pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;支持向量机&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 186pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;neighbors&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;KNeighborsClassifier&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 184pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;K&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;最近邻分类&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 186pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;naive_bayes&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;GaussianNB&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 184pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;高斯朴素贝叶斯&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 186pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;tree&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;DecisionTreeClassifier&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 184pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;分类决策树&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 186pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;ensemble&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;RandomForestClassifier&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 184pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;随机森林分类&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 186pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;ensemble&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 263pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;GradientBoostingClassifier&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 184pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;梯度提升分类树&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 style=&#34;margin-left: 0in;&#34;&gt;&lt;a name=&#34;t51&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t51&#34;&gt;&lt;/a&gt;&lt;strong&gt;分类模型的评价指标&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 212pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;方法名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 101pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;最佳值&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 240pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;sklearn函数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 212pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;Precision（精确率）&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 101pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;1.0&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 240pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;metrics.precision_score&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 212pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;Recall（召回率）&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 101pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;1.0&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 240pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;metrics.recall_score&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 212pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;F1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 101pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 240pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;metrics.f1_score&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 212pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Cohen’s Kappa&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;系数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 101pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 240pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;metrics.cohen_kappa_score&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 212pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;ROC&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;曲线&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 101pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;最靠近&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;轴&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 240pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;metrics. &lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;roc_curve&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div style=&#34;margin-left: .4in;&#34;&gt;分类模型评价方法前4种都是分值越高越好，其使用方法基本相同。&lt;/div&gt;
&lt;div style=&#34;margin-left: .4in;&#34;&gt;&lt;strong&gt;ROC曲线&lt;/strong&gt;&lt;/div&gt;
&lt;div style=&#34;margin-left: .4in;&#34;&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .4in;&#34;&gt;除了使用数值，表格形式评估分类模型的性能，还可通过绘制ROC曲线的方式来评估分类模型。&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .4in;&#34;&gt;ROC曲线横纵坐标范围为[0,1]，通常情况下ROC曲线与X轴形成的面积越大，表示模型性能越好。但是当ROC曲线处于下图中蓝色虚线的位置，就表明了模型的计算结果基本都是随机得来的，在此种情况下模型起到的作用几乎为零。故在实际中ROC曲线离图中蓝色虚线越远表示模型效果越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: .4in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503144348471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;562&#34; height=&#34;319&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;a name=&#34;t52&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t52&#34;&gt;&lt;/a&gt;构建并评价回归模型&lt;/h2&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/2020050314451924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;478&#34; height=&#34;455&#34; /&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t53&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t53&#34;&gt;&lt;/a&gt;常用回归模型&lt;/h3&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 133pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;回归模型名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 150pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;适用条件&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 250pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;算法描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 133pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;线性回归&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 182pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;因变量与自变量是线性关系&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 470pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;对一个或多个自变量和因变量之间的线性关系进行建模，可用最小二乘法求解模型系数。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 133pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;非线性回归&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 182pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;因变量与自变量之间不都是线性关系&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 470pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;对一个或多个自变量和因变量之间的非线性关系进行建模。如果非线性关系可以通过简单的函数变换转化成线性关系，用线性回归的思想求解；如果不能转化，用非线性最小二乘方法求解。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 133pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Logistic&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;回归&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 182pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;因变量一般有&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;（是与否）两种取值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 470pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是广义线性回归模型的特例，利用&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;Logistic&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;函数将因变量的取值范围控制在&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;和&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;之间，表示取值为&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;的概率。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 133pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;岭回归&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 182pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;参与建模的自变量之间具有多重共线性&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 470pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;是一种改进最小二乘估计的方法。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 133pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;主成分回归&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 182pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;参与建模的自变量之间具有多重共线性&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: justify; vertical-align: middle; width: 470pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;主成分回归是根据主成分分析的思想提出来的，是对最小二乘法的一种改进，它是参数估计的一种有偏估计。可以消除自变量之间的多重共线性。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t54&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t54&#34;&gt;&lt;/a&gt;&lt;strong&gt;sklearn库常用回归算法函数&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 150pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;模块名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 230pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;函数名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 130pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;算法名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 214pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;linear_model&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 324pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;LinearRegression&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 181pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;线性回归&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 214pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;svm&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 324pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;SVR&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 181pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;支持向量回归&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 214pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;neighbors&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 324pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;KNeighborsRegressor&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 181pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;最近邻回归&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 214pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;tree&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 324pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;DecisionTreeRegressor&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 181pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;回归决策树&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 214pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;ensemble&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 324pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;RandomForestRegressor&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 181pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;随机森林回归&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 214pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;ensemble&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 324pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;GradientBoostingRegressor&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 181pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;梯度提升回归树&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t55&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t55&#34;&gt;&lt;/a&gt;回归模型评价指标&lt;/h3&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .4in;&#34;&gt;回归模型的性能评估不同于分类模型，虽然都是对照真实值进行评估，但由于回归模型的预测结果和真实值都是连续的，所以不能够求取Precision、Recall和F1值等评价指标。回归模型拥有一套独立的评价指标。&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .4in;&#34;&gt;平均绝对误差、均方误差和中值绝对误差的值越靠近0，模型性能越好。可解释方差值和R方值则越靠近1，模型性能越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;table-box&#34;&gt;
&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 150pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;方法名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 60pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;最优值&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 334pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;strong&gt;sklearn函数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 226pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;平均绝对误差&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 103pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;0.0&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 354pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;metrics. mean_absolute_error&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 226pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;均方误差&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 103pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 354pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;metrics. mean_squared_error&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 226pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;中值绝对误差&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 103pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;0.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 354pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;metrics. median_absolute_error&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 226pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;可解释方差值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 103pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 354pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;metrics. explained_variance_score&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 226pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;方值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 103pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;1.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&#34;border-color: #ffffff; text-align: center; vertical-align: middle; width: 354pt;&#34;&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;metrics. r2_score&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t56&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t56&#34;&gt;&lt;/a&gt;使用scikit-learn构建模型小结&lt;/h2&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .3in;&#34;&gt;sklearn数据分析技术的基本任务主要体现在聚类、分类和回归三类。&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .3in;&#34;&gt;每一类又有对应的多种评估方法，能够评价所构建模型的性能优劣。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t58&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t58&#34;&gt;&lt;/a&gt;&lt;span style=&#34;color: #f33b45;&#34;&gt;模型评估与选择&lt;/span&gt;&lt;/h1&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t59&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t59&#34;&gt;&lt;/a&gt;1.评估方法&lt;/h2&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t60&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t60&#34;&gt;&lt;/a&gt;1-1）留出法&lt;/h3&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .25in;&#34;&gt;训练集＋测试集：互斥互补&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .25in;&#34;&gt;训练集训练模型，测试集测试模型&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .25in;&#34;&gt;合理划分、保持比例&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .25in;&#34;&gt;单次留出与多次留出&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .25in;&#34;&gt;多次留出法：如对专家样本随机进行100次训练集／测试集划分，评估结果取平均&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t61&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t61&#34;&gt;&lt;/a&gt;1-2）交叉验证法&lt;/h3&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .25in;&#34;&gt;K折交叉验证：将专家样本等份划分为K个数据集，轮流用K－1个用于训练，1个用于测试&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .25in;&#34;&gt;P次K折交叉验证&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-left: .25in;&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/2020050314543498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; width=&#34;476&#34; height=&#34;253&#34; /&gt;&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t62&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t62&#34;&gt;&lt;/a&gt;1-3）自助法&lt;/h3&gt;
&lt;h2 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t63&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t63&#34;&gt;&lt;/a&gt;2.性能度量&lt;/h2&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t64&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t64&#34;&gt;&lt;/a&gt;2-1）均方误差&lt;/h3&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t65&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t65&#34;&gt;&lt;/a&gt;2-2）错误率和精度：&lt;/h3&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;错误率：分类错误样本数占总样本数比例&lt;/p&gt;
&lt;p style=&#34;margin-left: 0cm;&#34;&gt;精度：1-错误率，分类正确样本数占总样本数比例&lt;/p&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t66&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t66&#34;&gt;&lt;/a&gt;2-3）查准率和查全率&lt;/h3&gt;
&lt;h3 style=&#34;margin-left: 0cm;&#34;&gt;&lt;a name=&#34;t67&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t67&#34;&gt;&lt;/a&gt;2-4）F1系数&lt;/h3&gt;
&lt;h2&gt;&lt;a name=&#34;t68&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t68&#34;&gt;&lt;/a&gt;3.偏差与方差&lt;/h2&gt;
&lt;p style=&#34;margin-left: 0in;&#34;&gt;泛化错误率的构成：偏差＋方差＋噪声&lt;/p&gt;
&lt;ul&gt;
 	&lt;li style=&#34;margin-left: .25in;&#34;&gt;偏差：模型输出与真实值的偏离程度，刻画了算法的拟合能力&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .25in;&#34;&gt;方差：同样大小的训练集的变动导致的学习性能的变化，即数据扰动造成的影响&lt;/li&gt;
 	&lt;li style=&#34;margin-left: .25in;&#34;&gt;噪声：当前学习器所能达到的泛化误差的下限&lt;/li&gt;
&lt;/ul&gt;
偏差大：拟合不足／欠拟合；方差大：过拟合
&lt;hr /&gt;
&lt;p&gt;原文：&lt;a href=&#34;https://blog.csdn.net/weixin_43717681/article/details/105894868&#34;&gt;https://blog.csdn.net/weixin_43717681/article/details/105894868&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;">探索性数据分析EDA(Exploratory Data Analysis)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/zuo-ye-11/"" data-c="
          &lt;p&gt;在数据管理技术发展过程中，完全需要应用程序自己动手管理数据的是&lt;strong&gt;人工管理阶段&lt;/strong&gt;&lt;br&gt;
长期存储在计算机内，有组织的、可共享的大量数据的集合是&lt;strong&gt;数据库（DataBase）&lt;/strong&gt;&lt;br&gt;
数据管理技术经历了若干阶段，其中人工管理阶段和文件系统阶段相比文件系统的一个显著的优势是&lt;strong&gt;数据可以长期保存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt; 数据不保存，不共享，不具备独立性的阶段是&lt;strong&gt;人工管理阶段&lt;/strong&gt;&lt;/span&gt;&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt; 数据具有整体结构化的特征，是在&lt;strong&gt;数据库系统阶段&lt;/strong&gt;&lt;/span&gt;&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt; 可以编程管理、保存数据，但是程序与数据具有较强的耦合性，数据独立性差，数据格式的改变会带来程序代码的改变，指的是&lt;strong&gt;文件系统阶段&lt;/strong&gt;&lt;/span&gt;&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt; 有较强的安全性，能够进行完整性检查和并发控制，出了故障有较为可靠的恢复手段，指的是&lt;strong&gt;数据库系统阶段&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;DBMS指的是&lt;strong&gt;数据库管理系统&lt;/strong&gt;（DataBase Management System）&lt;br&gt;
DataBase（&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;DB&lt;/span&gt;）是&lt;strong&gt;数据库&lt;/strong&gt;&lt;br&gt;
Data指的是&lt;strong&gt;数据&lt;/strong&gt;&lt;br&gt;
DBS是&lt;strong&gt;数据库系统&lt;/strong&gt;&lt;br&gt;
DDL指的是&lt;strong&gt;数据定义语言&lt;/strong&gt;&lt;br&gt;
DBA指的是&lt;strong&gt;数据库管理员&lt;/strong&gt;&lt;br&gt;
Eclipse是一种&lt;strong&gt;应用开发工具&lt;/strong&gt;&lt;br&gt;
MySQL是一种&lt;strong&gt;数据库管理系统、数据库&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;数字、声音、文本、图像、视频...可以被采集、编码、存储到计算机作为数据&lt;/p&gt;
&lt;p&gt;数据库管理系统对数据的统一管理和控制功能包括&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 数据的安全性保护&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 数据的完整性检查&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 并发控制&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 数据库恢复&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;是数据库中存储的基本对象&lt;br&gt;
&lt;strong&gt;数据&lt;/strong&gt;与其&lt;strong&gt;语义&lt;/strong&gt;是密不可分的&lt;br&gt;
数据库是长期存储在计算机内的，&lt;strong&gt;有组织&lt;/strong&gt;、&lt;strong&gt;可共享&lt;/strong&gt;的大量数据的集合。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;数据库&lt;/strong&gt;&lt;br&gt;
数据库是长期储存在计算机内有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、 描述和储存，具有较小的冗余度(redundaney)、较高的数据独立性(data independency)和易扩展性(scalabiliy), 并可为各种用户共享。&lt;/p&gt;
&lt;p&gt;数据库数据基中特点，永久存储、有组织的、可共享的&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;数据库管理系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;他的主要功能包括以下几个方面：&lt;br&gt;
1.数据定义功能&lt;br&gt;
2.数据组织、存储和管理&lt;br&gt;
3.数据操作功能&lt;br&gt;
4.数据库的事务管理和运行管理&lt;br&gt;
5.数据库的建立和维护功能&lt;br&gt;
6.其他功能&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;数据库系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator，DBA）组成的存储、管理、处理和维护数据的系统。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;人工管理阶段（20世纪50年代中期以前）&lt;/strong&gt;：&lt;br&gt;
1.数据不保存&lt;br&gt;
2.应用程序管理数据&lt;br&gt;
3.数据不共享&lt;br&gt;
4.数据不具有独立性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件系统阶段（20世纪50年代后期到60年代中期）&lt;/strong&gt;：&lt;br&gt;
优点：&lt;br&gt;
1.数据可以长期保存&lt;br&gt;
2.由文件系统管理数据&lt;br&gt;
缺点：&lt;br&gt;
1.数据共享性差，冗余度大&lt;br&gt;
数据独立性差&lt;/p&gt;
&lt;p&gt;与人工管理和文件系统相比，&lt;strong&gt;数据库系统的特点&lt;/strong&gt;主要有以下几个方面。&lt;br&gt;
1.数据结构化&lt;br&gt;
数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别&lt;br&gt;
2.数据的共享性高、冗余度低且易扩充&lt;br&gt;
3.数据独立性高&lt;br&gt;
4.数据由数据库管理西贡统一管理和控制&lt;br&gt;
数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制&lt;/p&gt;
&lt;p style=&#34;text-align: center;&#34;&gt;数据管理三个阶段的比较&lt;/p&gt;
&lt;img class=&#34;alignnone wp-image-221 size-full&#34; src=&#34;https://mingking.vip/wp-content/uploads/2020/06/TIM图片20200611111413.png&#34; alt=&#34;&#34; width=&#34;993&#34; height=&#34;647&#34; /&gt;">作业1.1</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/zuo-ye-12/"" data-c="
          &lt;p&gt;用来描述数据在内部的表示方法和存取方法的是&lt;strong&gt;物理模型&lt;/strong&gt;&lt;br&gt;
实现将现实世界抽象为信息世界的是&lt;strong&gt;概念模型&lt;/strong&gt;&lt;br&gt;
数据库系统的核心和基础是&lt;strong&gt;数据模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有学生组成了一类实体，这类实体用实体名及其属性集合来抽象表达，称为&lt;strong&gt;实体型&lt;/strong&gt;&lt;br&gt;
全体学生组成了一个集合，这集合称为实体集&lt;/p&gt;
&lt;p&gt;现在让你针对学校设计一个管理系统，你根据看到的景象，提笔写下：&lt;br&gt;
学校包含以下实体型：&lt;br&gt;
1、学生（学号，姓名，性别，出生日期，所在学院）&lt;br&gt;
2、学院（学院代码，学院名称，所在地点）&lt;br&gt;
3、教师（工号，姓名，性别，出生日期，所属学院）&lt;br&gt;
……&lt;br&gt;
这属于信息世界&lt;/p&gt;
&lt;p&gt;现在让你针对学校设计一个管理系统，你根据之前所做的工作，确定以下实现策略：&lt;br&gt;
学生信息定义为一个结构体，组织在一个B+Tree中……&lt;br&gt;
这属于机器世界&lt;/p&gt;
&lt;p&gt;数据模型的组成要素&lt;br&gt;
• 数据结构&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 数据操作&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 数据的完整性约束条件&lt;/p&gt;
&lt;p&gt;下列应用场景，在概念模型里，属于一对多联系的是&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 学生和班级&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 学生和宿舍&lt;/p&gt;
&lt;p&gt;客观存在并可相互区分的事物称为实体&lt;br&gt;
数据模型中的 &lt;strong&gt;数据结构&lt;/strong&gt; 是对数据系统的静态特性的描述，&lt;strong&gt;数据操作&lt;/strong&gt;是对数据库系统的动态特性的描述&lt;/p&gt;
&lt;p&gt;两个实体之间的联系可以分为三种：&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 一对一联系&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 一对多联系&lt;br&gt;
&lt;span style=&#34;display: inline !important; float: none; background-color: #ffffff; color: #333333; cursor: text; font-family: &#39;Noto Serif&#39;,serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; line-height: inherit; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;&#34;&gt;•&lt;/span&gt; 多对多联系&lt;/p&gt;
&lt;p&gt;数据库系统的逻辑模型按照计算机的观点对数据建模，主要包括&lt;strong&gt;层次模型&lt;/strong&gt;、&lt;strong&gt;网状模型&lt;/strong&gt;、&lt;strong&gt;关系法模型&lt;/strong&gt;、面向对象模型、对象关系模型和半结构化模型&lt;/p&gt;
&lt;p&gt;ER图中，表示属性，用&lt;strong&gt;椭圆&lt;/strong&gt;图形&lt;br&gt;
&lt;strong&gt;矩形&lt;/strong&gt;表示实体&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;两类数据模型&lt;/strong&gt;&lt;br&gt;
根据模型应用的不同目的，可以将这些模型划分为两大类，它们分别属于两个不同的&lt;br&gt;
层次。第一类是概念模型，第二类是逻辑模型和物理模型。&lt;br&gt;
&lt;strong&gt;第一类概念模型&lt;/strong&gt;(conceptual model), 也称&lt;strong&gt;信息模型&lt;/strong&gt;，它是按用户的观点来对数据和&lt;br&gt;
信息建模，主要用于数据库设计。将现实世界抽象为信息世界&lt;br&gt;
&lt;strong&gt;第二类中的逻辑模型&lt;/strong&gt;主要包括层次模型(hierarchical model)、网状模型(network model)、关系模型(relational model)、面向对象数据模型(object oriented data model)和对象关系数据模型(object relational data model)、半结构化数据模型(semistructured data model)等。它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。&lt;br&gt;
第二类中的物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方式和存&lt;br&gt;
取方法，或在磁盘或磁带上的存储方式和存取方法&lt;br&gt;
概念模型：将现实世界中的客观对象抽象为某一种信息结构&lt;/p&gt;
&lt;p&gt;从现实世界到概念模型的转换是由数据库设计人员完成的:从概念模型到逻辑模型的转换可以由数据库设计人员完成，也可以用数据库设计工具协助设计人员完成;从逻辑模型到物理模型的转换主要是由数据库管理系统完成的。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;信息世界主要涉及以下一些概念。&lt;br&gt;
&lt;strong&gt;(1)实体(entity)&lt;/strong&gt;&lt;br&gt;
客观存在并可相互区别的事物称为实体。实体可以是具体的人、事、物，也可以是抽&lt;br&gt;
象的概念或联系，例如，一个职工、- 一个学生、一个部门、一门课、学生的一次选课、部&lt;br&gt;
门的一次订货、教师与院系的工作关系(即某位教师在某院系工作)等都是实体。&lt;br&gt;
&lt;strong&gt;(2)属性( attribute)&lt;/strong&gt;&lt;br&gt;
实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。例如，学生实&lt;br&gt;
体可以由学号、姓名、性别、出生年月、所在院系、入学时间等属性组成，属性组合&lt;br&gt;
(201315121, 张山，男，199505， 计算机系，2013) 即表征了一个学生。&lt;br&gt;
&lt;strong&gt;(3)码(key)&lt;/strong&gt;&lt;br&gt;
唯一标识实体的属性集称为码。例如学号是学生实体的码。&lt;br&gt;
&lt;strong&gt;(4)实体型(entity type)&lt;/strong&gt;&lt;br&gt;
具有相同属性的实体必然具有共同的特征和性质。用实体名及其属性名集合来抽象和&lt;br&gt;
刻画同类实体，称为实体型。例如，学生(学号，姓名，性别，出生年月，所在院系，入学时间)就是一个实体型。&lt;br&gt;
&lt;strong&gt;(5)实体集(entity set)&lt;/strong&gt;&lt;br&gt;
同一类型实体的集合称为实体集。例如，全体学生就是一个实体集。&lt;br&gt;
&lt;strong&gt;(6)联系(relationship)&lt;/strong&gt;&lt;br&gt;
在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实&lt;br&gt;
体(型)内部的联系和实体(型)之间的联系。实体内部的联系通常是指组成实体的各属&lt;br&gt;
性之间的联系，实体之间的联系通常是指不同实体集之间的联系。&lt;br&gt;
实体之间的联系有一对一 、一对 多和多对多等多种类型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;数据模型的组成要素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据模型通常由数据结构、数据操作和数据完整性构成&lt;/strong&gt;&lt;br&gt;
数据结构描述数据库的组成对象以及对象之间的联系。也就是说，数据结构描述的内容有两类:一类是与对象的类型、内容、性质有关的，如网状模型中的数据项、记录，关系模型中的域、属性、关系等;一 类是与数据之间联系有关的对象，如网状模型中的系型( set tvne)。&lt;/p&gt;
">作业1.2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/qi-mo-kao-shi-fu-xi-zi-liao-suan-shu-zong-jie/"" data-c="
          &lt;p&gt;&lt;strong&gt;存储容量&lt;/strong&gt;&lt;br&gt;
存储容量 = 存储单元个数 x 存储字长&lt;br&gt;
MAR的位数反映了存储单元的个数，MDR的位数反映了存储字长。&lt;br&gt;
例如：&lt;br&gt;
若MAR6位，MDR10位，则存储字长为 10 位，存储单元的个数为 2**6&lt;br&gt;
存储容量为 10*64&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线带宽&lt;/strong&gt;&lt;br&gt;
如果总线工作频率为33MHz,总线宽度为32位,则总线带宽为( )。&lt;br&gt;
33 *（32 / 8）= 132 MBps&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;半导体存储芯片&lt;/strong&gt;&lt;br&gt;
某芯片容量为512k*8b，该芯片的地址线和数据线分别为（）&lt;br&gt;
地址线：512K = 2的19次方 所以地址线为19&lt;br&gt;
数据线：为8&lt;/p&gt;
&lt;p&gt;汉明码计算&lt;img class=&#34;alignnone size-medium wp-image-230&#34; src=&#34;https://mingking.vip/wp-content/uploads/2020/06/1091061-20170517181829525-4484565841-300x84.png&#34; alt=&#34;&#34; width=&#34;300&#34; height=&#34;84&#34; /&gt;&lt;br&gt;
四位：&lt;br&gt;
C1 = 1+3+4&lt;br&gt;
C2 = 1+2+4&lt;br&gt;
C4 = 1+2+3&lt;/p&gt;
&lt;p&gt;检测位&lt;br&gt;
已知欲发送的信息为1011，则需要添加几位检测位&lt;br&gt;
检测位k满足：&lt;br&gt;
2的k次方 &amp;gt;= n+k+1&lt;br&gt;
n为信息位数&lt;/p&gt;
">期末考试复习资料算数总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/shu-ju-ku-de-bu-fen-yi-lai-wan-quan-yi-lai-chuan-di-yi-lai-yi-ji-san-chong-fan-shi/"" data-c="
          &lt;div class=&#34;blog-content-box&#34;&gt;
&lt;div class=&#34;article-header-box&#34;&gt;
&lt;div class=&#34;article-header&#34;&gt;
&lt;div class=&#34;article-title-box&#34;&gt;&lt;/div&gt;
&lt;div class=&#34;article-info-box&#34;&gt;
&lt;div class=&#34;blog-tags-box&#34;&gt;&lt;/div&gt;
&lt;div class=&#34;up-time&#34; style=&#34;left: 110.188px; display: none;&#34;&gt;最后发布:2017-08-15 11:50:13首发:2017-08-15 11:50:13&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;article class=&#34;baidu_pl&#34;&gt;
&lt;div id=&#34;article_content&#34; class=&#34;article_content clearfix&#34;&gt;
&lt;div id=&#34;content_views&#34; class=&#34;markdown_views prism-atom-one-dark&#34;&gt;
&lt;h3 id=&#34;部分函数依赖设xy是关系r的两个属性集合存在xy若x是x的真子集存在xy则称y部分函数依赖于x&#34;&gt;&lt;a name=&#34;t0&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t0&#34;&gt;&lt;/a&gt;&lt;strong&gt;部分函数依赖&lt;/strong&gt;：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。&lt;/h3&gt;
&lt;blockquote&gt;举个例子：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;完全函数依赖设xy是关系r的两个属性集合x是x的真子集存在xy但对每一个x都有xy则称y完全函数依赖于x&#34;&gt;&lt;a name=&#34;t1&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t1&#34;&gt;&lt;/a&gt;&lt;strong&gt;完全函数依赖&lt;/strong&gt;：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。&lt;/h3&gt;
&lt;blockquote&gt;举个例子：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB.&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;传递函数依赖设xyz是关系r中互不相同的属性集合存在xyy-xyz则称z传递函数依赖于x&#34;&gt;&lt;a name=&#34;t2&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t2&#34;&gt;&lt;/a&gt;&lt;strong&gt;传递函数依赖&lt;/strong&gt;：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。&lt;/h3&gt;
&lt;blockquote&gt;举个例子：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20181124092930283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhbmRsZV9saWdodA==,size_16,color_FFFFFF,t_70&#34; /&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;三种范式&#34;&gt;&lt;a name=&#34;t3&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t3&#34;&gt;&lt;/a&gt;&lt;strong&gt;三种范式&lt;/strong&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1 、第一范式（1NF）&lt;br&gt;
在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。&lt;br&gt;
所谓第一范式（1NF）是指数据库表的每一列(即每个属性)都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。简而言之，第一范式就是无重复的列。&lt;/p&gt;
&lt;p&gt;2、 第二范式（2NF）&lt;br&gt;
第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。&lt;br&gt;
第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是非主属性依赖于主关键字。&lt;/p&gt;
&lt;p&gt;3 、第三范式（3NF）&lt;br&gt;
满足第三范式（3NF）必须先满足第二范式（2NF）。在满足第二范式的基础上，切不存在传递函数依赖，那么就是第三范式。简而言之，第三范式就是属性不依赖于其它非主属性。&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;简而言之&#34;&gt;&lt;a name=&#34;t4&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t4&#34;&gt;&lt;/a&gt;简而言之&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。&lt;/p&gt;
&lt;p&gt;2、第二范式（2NF）：满足第一范式，然后消除非主属性对码的部分依赖。&lt;/p&gt;
&lt;p&gt;3、第三范式（3NF）： 满足第二范式，消除了非主属性对码的部分和传递依赖。&lt;/p&gt;
&lt;p&gt;4.BC范式（BCNF）：满足第三范式，消除了主属性对码的部分和传递函数依赖&lt;/p&gt;
&lt;p&gt;5.第四范式（4NF）：满足BCNF，消除非平凡且非函数的多值依赖&lt;/blockquote&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;&lt;/div&gt;">数据库的部分依赖，完全依赖，传递依赖以及三种范式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/scikit-learn-ku-gai-shu/"" data-c="
          &lt;div class=&#34;htmledit_views&#34; id=&#34;content_views&#34;&gt;
  &lt;ul&gt;&lt;li&gt;该库最早由数据科学家David Cournapeau在2007年发起，使用需要Numpy和Scipy等其他库的支持，是Python中专门针对机器学习应用而发展起来的一款开源扩展库&lt;/li&gt;
	&lt;li&gt;和其他开源项目一样，该库主要由社区成员自发进行维护&lt;/li&gt;
	&lt;li&gt;scikit-learn与其他开源项目相比显得更为保守：一是scikit-learn从来不做除机器学习领域之外的其他扩展，而是scikit-learn从来不采用未经广泛验证的算法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&#34;https://scikit-learn.org/stable/index.html&#34; rel=&#34;nofollow&#34;&gt;https://scikit-learn.org/stable/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;t0&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t0&#34;&gt;&lt;/a&gt;Scikit-Learn库数据集&lt;/h2&gt;
&lt;p&gt;在机器学习中，经常需要使用各种各样的数据集，Scikit-Learn库提供了一些常用的数据集&lt;/p&gt;
&lt;div class=&#34;table-box&#34;&gt;&lt;table border=&#34;1&#34; cellpadding=&#34;1&#34; cellspacing=&#34;1&#34; style=&#34;width:500px;&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;序号&lt;/td&gt;
			&lt;td&gt;数据集名称&lt;/td&gt;
			&lt;td&gt;调用数据集&lt;/td&gt;
			&lt;td&gt;数据描述&lt;/td&gt;
		&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
			&lt;td&gt;鸢尾花数据集&lt;/td&gt;
			&lt;td&gt;Load_iris()&lt;/td&gt;
			&lt;td&gt;用于多分类任务的数据集&lt;/td&gt;
		&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
			&lt;td&gt;波士顿房价数据集&lt;/td&gt;
			&lt;td&gt;Load_boston()&lt;/td&gt;
			&lt;td&gt;用于回归任务的经典数据集&lt;/td&gt;
		&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
			&lt;td&gt;糖尿病数据集&lt;/td&gt;
			&lt;td&gt;Load_diabetes()&lt;/td&gt;
			&lt;td&gt;用于回归任务的经典数据集&lt;/td&gt;
		&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
			&lt;td&gt;毛写数字数据集&lt;/td&gt;
			&lt;td&gt;Load_digits()&lt;/td&gt;
			&lt;td&gt;用于多分类任务的数据集&lt;/td&gt;
		&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
			&lt;td&gt;乳腺癌数据集&lt;/td&gt;
			&lt;td&gt;Load_breast_cancer()&lt;/td&gt;
			&lt;td&gt;经典的用于二分类任务的数据集&lt;/td&gt;
		&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;
			&lt;td&gt;体能训练数据集&lt;/td&gt;
			&lt;td&gt;Load_linnerud()&lt;/td&gt;
			&lt;td&gt;经典的用于多变量回归任务的数据集&lt;/td&gt;
		&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;h2&gt;&lt;a name=&#34;t1&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t1&#34;&gt;&lt;/a&gt;&amp;nbsp;&lt;/h2&gt;
&lt;h2&gt;&lt;a name=&#34;t2&#34;&gt;&lt;/a&gt;&lt;img alt=&#34;&#34; height=&#34;771&#34; src=&#34;https://img-blog.csdnimg.cn/20200512165536555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; width=&#34;1200&#34;&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;a name=&#34;t3&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t3&#34;&gt;&lt;/a&gt;Scikit-Learn库功能&amp;nbsp;&lt;/h2&gt;
&lt;h3&gt;&lt;a name=&#34;t4&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t4&#34;&gt;&lt;/a&gt;分类：&lt;/h3&gt;
&lt;p&gt;分类是指识别给定对象的所属类别，属于检测学习的范畴，最常见的应用场景包括垃圾邮件检测和图像识别等&lt;/p&gt;
&lt;p&gt;目前Scikit-learn已经实现的算法包括：支持向量机（SVM），最近邻、逻辑回归、随机森林、决策树以及多层感知器（MLP）神经网络等&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t5&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t5&#34;&gt;&lt;/a&gt;回归：&lt;/h3&gt;
&lt;p&gt;回归是指预测与给定对象相关联的连续值属性，最常用的应用场景包括预测药物反应和预测股票价格等&lt;/p&gt;
&lt;p&gt;目前Scikit-Learn已经实现的算法包括：支持向量回归（SVR），脊回归，Lasso回归，弹性网络（ElasticNet），最小角回归（LARS），贝叶斯回归，以及各种不同的鲁棒回归算法等&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t6&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t6&#34;&gt;&lt;/a&gt;聚类：&lt;/h3&gt;
&lt;p&gt;聚类是指自动识别具有相似属性的给定对象，并将其分组为集合，数据无监督学习范畴&lt;/p&gt;
&lt;p&gt;最常见的应用场景包括顾客细分和实验结果分组。&lt;/p&gt;
&lt;p&gt;目前Scikit-Learn已经实现的算法包括：K-均值聚类、谱聚类、均值偏移、分层聚类、DBSCAN聚类等&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t7&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t7&#34;&gt;&lt;/a&gt;数据降维：&lt;/h3&gt;
&lt;p&gt;数据降维是指使用主成分分析（PCA），非矩阵分解（NMF）或特征选择等降维技术来减少要考虑的随机变量的个数，其主要应用场景包括可视化处理和效率提升&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t8&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t8&#34;&gt;&lt;/a&gt;模型选择：&lt;/h3&gt;
&lt;p&gt;模型选择是指对于给定参数和模型的比较、验证和选择，其主要目的是通过参数调整来提升精度。&lt;/p&gt;
&lt;p&gt;目前Scikit-Learn实现的模块包括：格点搜索、交叉验证和各种针对预测误差评估的度量函数&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t9&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t9&#34;&gt;&lt;/a&gt;数据预处理：&lt;/h3&gt;
&lt;p&gt;数据预处理是指数据的特征提取和归一化，是机器学习过程中的第一个也是最重要的一个环节&lt;/p&gt;
&lt;p&gt;归一化是指将输入数据转化为具有零均值（中心化）和单位权方差的新变量，但因为大多数时候都做不到精确等于零，因此会设置一个可接受的范围，一般都要求落在0-1之间&lt;/p&gt;
&lt;p&gt;特征提取是指将文本或图像数据转换为可用于机器学习的数据变量&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;t10&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t10&#34;&gt;&lt;/a&gt;Scikit-Learn库分类算法&lt;/h2&gt;
&lt;h3&gt;&lt;a name=&#34;t11&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t11&#34;&gt;&lt;/a&gt;K近邻分类器（KNN）&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; height=&#34;721&#34; src=&#34;https://img-blog.csdnimg.cn/20200512170715504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; width=&#34;1200&#34;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;img alt=&#34;&#34; height=&#34;807&#34; src=&#34;https://img-blog.csdnimg.cn/20200512171105723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; width=&#34;1200&#34;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
from sklearn.neighbors import KNeighborsClassifier
#创建一组数据X和它对应的标签y
X=[[0],[1],[2],[3],[4],[5]]
y=[0,0,0,1,1,1]
#使用最近的3个邻居作为分类的依据，得到分类器
neigh=KNeighborsClassifier(n_neighbors=3)
#将训练数据X和标签y送入分类器进行学习
neigh.fit(X,y)
#调用predict（）函数，对未知分类样本[1.1]分类，可以直接并将
#需要分类的数据构造为数组形式作为参数传入，得到分类标签作为返回值
print(neigh.predict([[1.4]]))
print(neigh.predict([[2.4]]))
print(neigh.predict([[2.5]]))
print(neigh.predict([[2.6]]))

输出：
[0]
[0]
[0]
[1]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;a name=&#34;t12&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t12&#34;&gt;&lt;/a&gt;决策树&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; height=&#34;869&#34; src=&#34;https://img-blog.csdnimg.cn/20200512171242496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; width=&#34;1200&#34;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;img alt=&#34;&#34; height=&#34;754&#34; src=&#34;https://img-blog.csdnimg.cn/20200512171405450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; width=&#34;1200&#34;&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&#34;t13&#34;&gt;&lt;/a&gt;&lt;a name=&#34;t13&#34;&gt;&lt;/a&gt;&amp;nbsp;回归算法&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; height=&#34;569&#34; src=&#34;https://img-blog.csdnimg.cn/20200512171748965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; width=&#34;1200&#34;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;img alt=&#34;&#34; height=&#34;909&#34; src=&#34;https://img-blog.csdnimg.cn/20200512171823502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxNzY4MQ==,size_16,color_FFFFFF,t_70&#34; width=&#34;1200&#34;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                    &lt;/div&gt;&lt;div data-report-view=&#34;{&amp;quot;mod&amp;quot;:&amp;quot;1585297308_001&amp;quot;,&amp;quot;dest&amp;quot;:&amp;quot;https://blog.csdn.net/weixin_43717681/article/details/106074726&amp;quot;,&amp;quot;extend1&amp;quot;:&amp;quot;pc&amp;quot;,&amp;quot;ab&amp;quot;:&amp;quot;new&amp;quot;}&#34;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;
                                &lt;/div&gt;
    &lt;/article&gt;
&lt;/div&gt;">Scikit-Learn库概述</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/K-近邻算法/"" data-c="
          &lt;p&gt;基于电影中出现的亲吻，打斗出现的次数，使用K-近邻算法构造程序，自动划分电影的题材类型，是爱情片、动作片还是、、、、、。&lt;/p&gt;
&lt;p&gt;K-近邻算法采用测量不同特征值之间的距离方法进行分类&lt;/p&gt;
&lt;p&gt;K-近邻算法&lt;br&gt;
优点：精度高，对异常值不敏感，无数据输入假定&lt;br&gt;
缺点：计算复杂度高，空间复杂度高&lt;br&gt;
适用数据范围：数值型和标称型&lt;br&gt;
标称型：标称型目标变量的结果只在有限目标集中取值，如真与假(标称型目标变量主要用于分类)标称型：标称型目标变量的结果只在有限目标集中取值，如真与假(标称型目标变量主要用于分类)&lt;br&gt;
数值型：数值型目标变量则可以从无限的数值集合中取值，如0.100，42.001等 (数值型目标变量主要用于回归分析)&lt;/p&gt;
&lt;p&gt;K-近邻算法是分类数据最简单最有效的算法。K-近邻算法是基于实例的学习，使用算法时我们必须有接近实际数据的训练样本数据。K-近邻算法必须保存全部数据集，如果训练数据集很大，必须使用大量的存储空间。此外，由于必须对数据集中的每个数据计算距离值，实际使用时可能非常耗时。K-近邻算法的另一个缺陷是它无法给出任何数据的基础结构信息，因此我们也无法知晓平均实例样本和典型实例样本具有什么特征。&lt;/p&gt;
&lt;pre&gt; 
&lt;code&gt;
from sklearn.neighbors import KNeighborsClassifierNei
from sklearn.neighbors import KNeighborsClassifier
#创建一组数据X和它对应的标签y
X=[[0],[1],[2],[3],[4],[5]]
y=[0,0,0,1,1,1]
#使用最近的3个邻居作为分类的依据，得到分类器
neigh=KNeighborsClassifier(n_neighbors=3)
#将训练数据X和标签y送入分类器进行学习
neigh.fit(X,y)
#调用predict（）函数，对未知分类样本[1.1]分类，可以直接并将
#需要分类的数据构造为数组形式作为参数传入，得到分类标签作为返回值
print(neigh.predict([[1.4]]))
print(neigh.predict([[2.4]]))
print(neigh.predict([[2.5]]))
print(neigh.predict([[2.6]]))

输出：
[0]
[0]
[0]
[1]
&lt;/code&gt;
&lt;/pre&gt;
">K-近邻算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;aaaaaaaaaaaa&lt;/p&gt;
&lt;p&gt;a&lt;br&gt;
a&lt;/p&gt;
&lt;p&gt;a&lt;br&gt;
a&lt;br&gt;
a&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dm24530.GitHub.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="https://cdn.jsdelivr.net/gh/dm24530/dm24530.github.io@master/media/js/motion.js"></script>



<script src="/media/js/mouse/peace.js"></script>


<script src="https://cdn.jsdelivr.net/gh/dm24530/dm24530.github.io@master/media/js/cool.js"></script>




</html>